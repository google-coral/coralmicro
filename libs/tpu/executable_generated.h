/*
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EXECUTABLE_PLATFORMS_DARWINN_H_
#define FLATBUFFERS_GENERATED_EXECUTABLE_PLATFORMS_DARWINN_H_

#include "flatbuffers/flatbuffers.h"

namespace platforms {
namespace darwinn {

struct Meta;
struct MetaT;

struct FieldOffset;
struct FieldOffsetT;

struct InstructionBitstream;
struct InstructionBitstreamT;

struct DmaDescriptorHint;
struct DmaDescriptorHintT;

struct InterruptHint;
struct InterruptHintT;

struct InstructionHint;
struct InstructionHintT;

struct FenceHint;
struct FenceHintT;

struct DmaHint;
struct DmaHintT;

struct DmaHints;
struct DmaHintsT;

struct OutputLayout;
struct OutputLayoutT;

struct Range;

struct TensorShape;
struct TensorShapeT;

struct TensorLayout;
struct TensorLayoutT;

struct OutputShapeInfo;
struct OutputShapeInfoT;

struct NumericsConstants;
struct NumericsConstantsT;

struct OutputLayer;
struct OutputLayerT;

struct InputLayer;
struct InputLayerT;

struct Layer;
struct LayerT;

struct Executable;
struct ExecutableT;

struct MultiExecutable;
struct MultiExecutableT;

struct SerializedPackage;
struct SerializedPackageT;

struct Package;
struct PackageT;

enum Description {
  Description_BASE_ADDRESS_OUTPUT_ACTIVATION = 0,
  Description_BASE_ADDRESS_INPUT_ACTIVATION = 1,
  Description_BASE_ADDRESS_PARAMETER = 2,
  Description_BASE_ADDRESS_SCRATCH = 3,
  Description_MIN = Description_BASE_ADDRESS_OUTPUT_ACTIVATION,
  Description_MAX = Description_BASE_ADDRESS_SCRATCH
};

inline const Description (&EnumValuesDescription())[4] {
  static const Description values[] = {
    Description_BASE_ADDRESS_OUTPUT_ACTIVATION,
    Description_BASE_ADDRESS_INPUT_ACTIVATION,
    Description_BASE_ADDRESS_PARAMETER,
    Description_BASE_ADDRESS_SCRATCH
  };
  return values;
}

inline const char * const *EnumNamesDescription() {
  static const char * const names[5] = {
    "BASE_ADDRESS_OUTPUT_ACTIVATION",
    "BASE_ADDRESS_INPUT_ACTIVATION",
    "BASE_ADDRESS_PARAMETER",
    "BASE_ADDRESS_SCRATCH",
    nullptr
  };
  return names;
}

inline const char *EnumNameDescription(Description e) {
  if (flatbuffers::IsOutRange(e, Description_BASE_ADDRESS_OUTPUT_ACTIVATION, Description_BASE_ADDRESS_SCRATCH)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDescription()[index];
}

enum Position {
  Position_LOWER_32BIT = 0,
  Position_UPPER_32BIT = 1,
  Position_MIN = Position_LOWER_32BIT,
  Position_MAX = Position_UPPER_32BIT
};

inline const Position (&EnumValuesPosition())[2] {
  static const Position values[] = {
    Position_LOWER_32BIT,
    Position_UPPER_32BIT
  };
  return values;
}

inline const char * const *EnumNamesPosition() {
  static const char * const names[3] = {
    "LOWER_32BIT",
    "UPPER_32BIT",
    nullptr
  };
  return names;
}

inline const char *EnumNamePosition(Position e) {
  if (flatbuffers::IsOutRange(e, Position_LOWER_32BIT, Position_UPPER_32BIT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPosition()[index];
}

enum InterruptType {
  InterruptType_SCALAR_CORE_INT_0 = 0,
  InterruptType_SCALAR_CORE_INT_1 = 1,
  InterruptType_SCALAR_CORE_INT_2 = 2,
  InterruptType_SCALAR_CORE_INT_3 = 3,
  InterruptType_MIN = InterruptType_SCALAR_CORE_INT_0,
  InterruptType_MAX = InterruptType_SCALAR_CORE_INT_3
};

inline const InterruptType (&EnumValuesInterruptType())[4] {
  static const InterruptType values[] = {
    InterruptType_SCALAR_CORE_INT_0,
    InterruptType_SCALAR_CORE_INT_1,
    InterruptType_SCALAR_CORE_INT_2,
    InterruptType_SCALAR_CORE_INT_3
  };
  return values;
}

inline const char * const *EnumNamesInterruptType() {
  static const char * const names[5] = {
    "SCALAR_CORE_INT_0",
    "SCALAR_CORE_INT_1",
    "SCALAR_CORE_INT_2",
    "SCALAR_CORE_INT_3",
    nullptr
  };
  return names;
}

inline const char *EnumNameInterruptType(InterruptType e) {
  if (flatbuffers::IsOutRange(e, InterruptType_SCALAR_CORE_INT_0, InterruptType_SCALAR_CORE_INT_3)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInterruptType()[index];
}

enum Direction {
  Direction_INFEED = 0,
  Direction_OUTFEED = 1,
  Direction_MIN = Direction_INFEED,
  Direction_MAX = Direction_OUTFEED
};

inline const Direction (&EnumValuesDirection())[2] {
  static const Direction values[] = {
    Direction_INFEED,
    Direction_OUTFEED
  };
  return values;
}

inline const char * const *EnumNamesDirection() {
  static const char * const names[3] = {
    "INFEED",
    "OUTFEED",
    nullptr
  };
  return names;
}

inline const char *EnumNameDirection(Direction e) {
  if (flatbuffers::IsOutRange(e, Direction_INFEED, Direction_OUTFEED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDirection()[index];
}

enum AnyHint {
  AnyHint_NONE = 0,
  AnyHint_DmaDescriptorHint = 1,
  AnyHint_InstructionHint = 2,
  AnyHint_InterruptHint = 3,
  AnyHint_FenceHint = 4,
  AnyHint_MIN = AnyHint_NONE,
  AnyHint_MAX = AnyHint_FenceHint
};

inline const AnyHint (&EnumValuesAnyHint())[5] {
  static const AnyHint values[] = {
    AnyHint_NONE,
    AnyHint_DmaDescriptorHint,
    AnyHint_InstructionHint,
    AnyHint_InterruptHint,
    AnyHint_FenceHint
  };
  return values;
}

inline const char * const *EnumNamesAnyHint() {
  static const char * const names[6] = {
    "NONE",
    "DmaDescriptorHint",
    "InstructionHint",
    "InterruptHint",
    "FenceHint",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyHint(AnyHint e) {
  if (flatbuffers::IsOutRange(e, AnyHint_NONE, AnyHint_FenceHint)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnyHint()[index];
}

template<typename T> struct AnyHintTraits {
  static const AnyHint enum_value = AnyHint_NONE;
};

template<> struct AnyHintTraits<platforms::darwinn::DmaDescriptorHint> {
  static const AnyHint enum_value = AnyHint_DmaDescriptorHint;
};

template<> struct AnyHintTraits<platforms::darwinn::InstructionHint> {
  static const AnyHint enum_value = AnyHint_InstructionHint;
};

template<> struct AnyHintTraits<platforms::darwinn::InterruptHint> {
  static const AnyHint enum_value = AnyHint_InterruptHint;
};

template<> struct AnyHintTraits<platforms::darwinn::FenceHint> {
  static const AnyHint enum_value = AnyHint_FenceHint;
};

struct AnyHintUnion {
  AnyHint type;
  void *value;

  AnyHintUnion() : type(AnyHint_NONE), value(nullptr) {}
  AnyHintUnion(AnyHintUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(AnyHint_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  AnyHintUnion(const AnyHintUnion &) FLATBUFFERS_NOEXCEPT;
  AnyHintUnion &operator=(const AnyHintUnion &u) FLATBUFFERS_NOEXCEPT
    { AnyHintUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  AnyHintUnion &operator=(AnyHintUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~AnyHintUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = AnyHintTraits<typename RT::TableType>::enum_value;
    if (type != AnyHint_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, AnyHint type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  platforms::darwinn::DmaDescriptorHintT *AsDmaDescriptorHint() {
    return type == AnyHint_DmaDescriptorHint ?
      reinterpret_cast<platforms::darwinn::DmaDescriptorHintT *>(value) : nullptr;
  }
  const platforms::darwinn::DmaDescriptorHintT *AsDmaDescriptorHint() const {
    return type == AnyHint_DmaDescriptorHint ?
      reinterpret_cast<const platforms::darwinn::DmaDescriptorHintT *>(value) : nullptr;
  }
  platforms::darwinn::InstructionHintT *AsInstructionHint() {
    return type == AnyHint_InstructionHint ?
      reinterpret_cast<platforms::darwinn::InstructionHintT *>(value) : nullptr;
  }
  const platforms::darwinn::InstructionHintT *AsInstructionHint() const {
    return type == AnyHint_InstructionHint ?
      reinterpret_cast<const platforms::darwinn::InstructionHintT *>(value) : nullptr;
  }
  platforms::darwinn::InterruptHintT *AsInterruptHint() {
    return type == AnyHint_InterruptHint ?
      reinterpret_cast<platforms::darwinn::InterruptHintT *>(value) : nullptr;
  }
  const platforms::darwinn::InterruptHintT *AsInterruptHint() const {
    return type == AnyHint_InterruptHint ?
      reinterpret_cast<const platforms::darwinn::InterruptHintT *>(value) : nullptr;
  }
  platforms::darwinn::FenceHintT *AsFenceHint() {
    return type == AnyHint_FenceHint ?
      reinterpret_cast<platforms::darwinn::FenceHintT *>(value) : nullptr;
  }
  const platforms::darwinn::FenceHintT *AsFenceHint() const {
    return type == AnyHint_FenceHint ?
      reinterpret_cast<const platforms::darwinn::FenceHintT *>(value) : nullptr;
  }
};

bool VerifyAnyHint(flatbuffers::Verifier &verifier, const void *obj, AnyHint type);
bool VerifyAnyHintVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum DataType {
  DataType_FIXED_POINT8 = 0,
  DataType_FIXED_POINT16 = 1,
  DataType_SIGNED_FIXED_POINT32 = 2,
  DataType_BFLOAT = 3,
  DataType_HALF = 4,
  DataType_SINGLE = 5,
  DataType_SIGNED_FIXED_POINT8 = 8,
  DataType_SIGNED_FIXED_POINT16 = 9,
  DataType_MIN = DataType_FIXED_POINT8,
  DataType_MAX = DataType_SIGNED_FIXED_POINT16
};

inline const DataType (&EnumValuesDataType())[8] {
  static const DataType values[] = {
    DataType_FIXED_POINT8,
    DataType_FIXED_POINT16,
    DataType_SIGNED_FIXED_POINT32,
    DataType_BFLOAT,
    DataType_HALF,
    DataType_SINGLE,
    DataType_SIGNED_FIXED_POINT8,
    DataType_SIGNED_FIXED_POINT16
  };
  return values;
}

inline const char * const *EnumNamesDataType() {
  static const char * const names[11] = {
    "FIXED_POINT8",
    "FIXED_POINT16",
    "SIGNED_FIXED_POINT32",
    "BFLOAT",
    "HALF",
    "SINGLE",
    "",
    "",
    "SIGNED_FIXED_POINT8",
    "SIGNED_FIXED_POINT16",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  if (flatbuffers::IsOutRange(e, DataType_FIXED_POINT8, DataType_SIGNED_FIXED_POINT16)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataType()[index];
}

enum AnyLayer {
  AnyLayer_NONE = 0,
  AnyLayer_OutputLayer = 1,
  AnyLayer_InputLayer = 2,
  AnyLayer_MIN = AnyLayer_NONE,
  AnyLayer_MAX = AnyLayer_InputLayer
};

inline const AnyLayer (&EnumValuesAnyLayer())[3] {
  static const AnyLayer values[] = {
    AnyLayer_NONE,
    AnyLayer_OutputLayer,
    AnyLayer_InputLayer
  };
  return values;
}

inline const char * const *EnumNamesAnyLayer() {
  static const char * const names[4] = {
    "NONE",
    "OutputLayer",
    "InputLayer",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyLayer(AnyLayer e) {
  if (flatbuffers::IsOutRange(e, AnyLayer_NONE, AnyLayer_InputLayer)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnyLayer()[index];
}

template<typename T> struct AnyLayerTraits {
  static const AnyLayer enum_value = AnyLayer_NONE;
};

template<> struct AnyLayerTraits<platforms::darwinn::OutputLayer> {
  static const AnyLayer enum_value = AnyLayer_OutputLayer;
};

template<> struct AnyLayerTraits<platforms::darwinn::InputLayer> {
  static const AnyLayer enum_value = AnyLayer_InputLayer;
};

struct AnyLayerUnion {
  AnyLayer type;
  void *value;

  AnyLayerUnion() : type(AnyLayer_NONE), value(nullptr) {}
  AnyLayerUnion(AnyLayerUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(AnyLayer_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  AnyLayerUnion(const AnyLayerUnion &) FLATBUFFERS_NOEXCEPT;
  AnyLayerUnion &operator=(const AnyLayerUnion &u) FLATBUFFERS_NOEXCEPT
    { AnyLayerUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  AnyLayerUnion &operator=(AnyLayerUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~AnyLayerUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = AnyLayerTraits<typename RT::TableType>::enum_value;
    if (type != AnyLayer_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, AnyLayer type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  platforms::darwinn::OutputLayerT *AsOutputLayer() {
    return type == AnyLayer_OutputLayer ?
      reinterpret_cast<platforms::darwinn::OutputLayerT *>(value) : nullptr;
  }
  const platforms::darwinn::OutputLayerT *AsOutputLayer() const {
    return type == AnyLayer_OutputLayer ?
      reinterpret_cast<const platforms::darwinn::OutputLayerT *>(value) : nullptr;
  }
  platforms::darwinn::InputLayerT *AsInputLayer() {
    return type == AnyLayer_InputLayer ?
      reinterpret_cast<platforms::darwinn::InputLayerT *>(value) : nullptr;
  }
  const platforms::darwinn::InputLayerT *AsInputLayer() const {
    return type == AnyLayer_InputLayer ?
      reinterpret_cast<const platforms::darwinn::InputLayerT *>(value) : nullptr;
  }
};

bool VerifyAnyLayer(flatbuffers::Verifier &verifier, const void *obj, AnyLayer type);
bool VerifyAnyLayerVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum ExecutableType {
  ExecutableType_STAND_ALONE = 0,
  ExecutableType_PARAMETER_CACHING = 1,
  ExecutableType_EXECUTION_ONLY = 2,
  ExecutableType_MIN = ExecutableType_STAND_ALONE,
  ExecutableType_MAX = ExecutableType_EXECUTION_ONLY
};

inline const ExecutableType (&EnumValuesExecutableType())[3] {
  static const ExecutableType values[] = {
    ExecutableType_STAND_ALONE,
    ExecutableType_PARAMETER_CACHING,
    ExecutableType_EXECUTION_ONLY
  };
  return values;
}

inline const char * const *EnumNamesExecutableType() {
  static const char * const names[4] = {
    "STAND_ALONE",
    "PARAMETER_CACHING",
    "EXECUTION_ONLY",
    nullptr
  };
  return names;
}

inline const char *EnumNameExecutableType(ExecutableType e) {
  if (flatbuffers::IsOutRange(e, ExecutableType_STAND_ALONE, ExecutableType_EXECUTION_ONLY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExecutableType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Range FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t start_;
  int32_t end_;

 public:
  Range() {
    memset(static_cast<void *>(this), 0, sizeof(Range));
  }
  Range(int32_t _start, int32_t _end)
      : start_(flatbuffers::EndianScalar(_start)),
        end_(flatbuffers::EndianScalar(_end)) {
  }
  int32_t start() const {
    return flatbuffers::EndianScalar(start_);
  }
  void mutate_start(int32_t _start) {
    flatbuffers::WriteScalar(&start_, _start);
  }
  int32_t end() const {
    return flatbuffers::EndianScalar(end_);
  }
  void mutate_end(int32_t _end) {
    flatbuffers::WriteScalar(&end_, _end);
  }
};
FLATBUFFERS_STRUCT_END(Range, 8);

struct MetaT : public flatbuffers::NativeTable {
  typedef Meta TableType;
  platforms::darwinn::Description desc;
  int32_t batch;
  std::string name;
  platforms::darwinn::Position position;
  MetaT()
      : desc(platforms::darwinn::Description_BASE_ADDRESS_OUTPUT_ACTIVATION),
        batch(0),
        position(platforms::darwinn::Position_LOWER_32BIT) {
  }
};

struct Meta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MetaT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DESC = 4,
    VT_BATCH = 6,
    VT_NAME = 8,
    VT_POSITION = 10
  };
  platforms::darwinn::Description desc() const {
    return static_cast<platforms::darwinn::Description>(GetField<int16_t>(VT_DESC, 0));
  }
  bool mutate_desc(platforms::darwinn::Description _desc) {
    return SetField<int16_t>(VT_DESC, static_cast<int16_t>(_desc), 0);
  }
  int32_t batch() const {
    return GetField<int32_t>(VT_BATCH, 0);
  }
  bool mutate_batch(int32_t _batch) {
    return SetField<int32_t>(VT_BATCH, _batch, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  platforms::darwinn::Position position() const {
    return static_cast<platforms::darwinn::Position>(GetField<int16_t>(VT_POSITION, 0));
  }
  bool mutate_position(platforms::darwinn::Position _position) {
    return SetField<int16_t>(VT_POSITION, static_cast<int16_t>(_position), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_DESC, sizeof(int16_t)) &&
           VerifyField<int32_t>(verifier, VT_BATCH, sizeof(int32_t)) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int16_t>(verifier, VT_POSITION, sizeof(int16_t)) &&
           verifier.EndTable();
  }
  MetaT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MetaT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Meta> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetaT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MetaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_desc(platforms::darwinn::Description desc) {
    fbb_.AddElement<int16_t>(Meta::VT_DESC, static_cast<int16_t>(desc), 0);
  }
  void add_batch(int32_t batch) {
    fbb_.AddElement<int32_t>(Meta::VT_BATCH, batch, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Meta::VT_NAME, name);
  }
  void add_position(platforms::darwinn::Position position) {
    fbb_.AddElement<int16_t>(Meta::VT_POSITION, static_cast<int16_t>(position), 0);
  }
  explicit MetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MetaBuilder &operator=(const MetaBuilder &);
  flatbuffers::Offset<Meta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Meta>(end);
    return o;
  }
};

inline flatbuffers::Offset<Meta> CreateMeta(
    flatbuffers::FlatBufferBuilder &_fbb,
    platforms::darwinn::Description desc = platforms::darwinn::Description_BASE_ADDRESS_OUTPUT_ACTIVATION,
    int32_t batch = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    platforms::darwinn::Position position = platforms::darwinn::Position_LOWER_32BIT) {
  MetaBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_batch(batch);
  builder_.add_position(position);
  builder_.add_desc(desc);
  return builder_.Finish();
}

inline flatbuffers::Offset<Meta> CreateMetaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    platforms::darwinn::Description desc = platforms::darwinn::Description_BASE_ADDRESS_OUTPUT_ACTIVATION,
    int32_t batch = 0,
    const char *name = nullptr,
    platforms::darwinn::Position position = platforms::darwinn::Position_LOWER_32BIT) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return platforms::darwinn::CreateMeta(
      _fbb,
      desc,
      batch,
      name__,
      position);
}

flatbuffers::Offset<Meta> CreateMeta(flatbuffers::FlatBufferBuilder &_fbb, const MetaT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FieldOffsetT : public flatbuffers::NativeTable {
  typedef FieldOffset TableType;
  std::unique_ptr<platforms::darwinn::MetaT> meta;
  int32_t offset_bit;
  FieldOffsetT()
      : offset_bit(0) {
  }
};

struct FieldOffset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FieldOffsetT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_META = 4,
    VT_OFFSET_BIT = 6
  };
  const platforms::darwinn::Meta *meta() const {
    return GetPointer<const platforms::darwinn::Meta *>(VT_META);
  }
  platforms::darwinn::Meta *mutable_meta() {
    return GetPointer<platforms::darwinn::Meta *>(VT_META);
  }
  int32_t offset_bit() const {
    return GetField<int32_t>(VT_OFFSET_BIT, 0);
  }
  bool mutate_offset_bit(int32_t _offset_bit) {
    return SetField<int32_t>(VT_OFFSET_BIT, _offset_bit, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_META) &&
           verifier.VerifyTable(meta()) &&
           VerifyField<int32_t>(verifier, VT_OFFSET_BIT, sizeof(int32_t)) &&
           verifier.EndTable();
  }
  FieldOffsetT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FieldOffsetT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FieldOffset> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FieldOffsetT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FieldOffsetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_meta(flatbuffers::Offset<platforms::darwinn::Meta> meta) {
    fbb_.AddOffset(FieldOffset::VT_META, meta);
  }
  void add_offset_bit(int32_t offset_bit) {
    fbb_.AddElement<int32_t>(FieldOffset::VT_OFFSET_BIT, offset_bit, 0);
  }
  explicit FieldOffsetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FieldOffsetBuilder &operator=(const FieldOffsetBuilder &);
  flatbuffers::Offset<FieldOffset> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FieldOffset>(end);
    return o;
  }
};

inline flatbuffers::Offset<FieldOffset> CreateFieldOffset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<platforms::darwinn::Meta> meta = 0,
    int32_t offset_bit = 0) {
  FieldOffsetBuilder builder_(_fbb);
  builder_.add_offset_bit(offset_bit);
  builder_.add_meta(meta);
  return builder_.Finish();
}

flatbuffers::Offset<FieldOffset> CreateFieldOffset(flatbuffers::FlatBufferBuilder &_fbb, const FieldOffsetT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InstructionBitstreamT : public flatbuffers::NativeTable {
  typedef InstructionBitstream TableType;
  std::vector<uint8_t> bitstream;
  std::vector<std::unique_ptr<platforms::darwinn::FieldOffsetT>> field_offsets;
  InstructionBitstreamT() {
  }
};

struct InstructionBitstream FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InstructionBitstreamT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BITSTREAM = 4,
    VT_FIELD_OFFSETS = 6
  };
  const flatbuffers::Vector<uint8_t> *bitstream() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BITSTREAM);
  }
  flatbuffers::Vector<uint8_t> *mutable_bitstream() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_BITSTREAM);
  }
  const flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::FieldOffset>> *field_offsets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::FieldOffset>> *>(VT_FIELD_OFFSETS);
  }
  flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::FieldOffset>> *mutable_field_offsets() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::FieldOffset>> *>(VT_FIELD_OFFSETS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BITSTREAM) &&
           verifier.VerifyVector(bitstream()) &&
           VerifyOffset(verifier, VT_FIELD_OFFSETS) &&
           verifier.VerifyVector(field_offsets()) &&
           verifier.VerifyVectorOfTables(field_offsets()) &&
           verifier.EndTable();
  }
  InstructionBitstreamT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InstructionBitstreamT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InstructionBitstream> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InstructionBitstreamT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InstructionBitstreamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bitstream(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bitstream) {
    fbb_.AddOffset(InstructionBitstream::VT_BITSTREAM, bitstream);
  }
  void add_field_offsets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::FieldOffset>>> field_offsets) {
    fbb_.AddOffset(InstructionBitstream::VT_FIELD_OFFSETS, field_offsets);
  }
  explicit InstructionBitstreamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InstructionBitstreamBuilder &operator=(const InstructionBitstreamBuilder &);
  flatbuffers::Offset<InstructionBitstream> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InstructionBitstream>(end);
    return o;
  }
};

inline flatbuffers::Offset<InstructionBitstream> CreateInstructionBitstream(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bitstream = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::FieldOffset>>> field_offsets = 0) {
  InstructionBitstreamBuilder builder_(_fbb);
  builder_.add_field_offsets(field_offsets);
  builder_.add_bitstream(bitstream);
  return builder_.Finish();
}

inline flatbuffers::Offset<InstructionBitstream> CreateInstructionBitstreamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *bitstream = nullptr,
    const std::vector<flatbuffers::Offset<platforms::darwinn::FieldOffset>> *field_offsets = nullptr) {
  auto bitstream__ = bitstream ? _fbb.CreateVector<uint8_t>(*bitstream) : 0;
  auto field_offsets__ = field_offsets ? _fbb.CreateVector<flatbuffers::Offset<platforms::darwinn::FieldOffset>>(*field_offsets) : 0;
  return platforms::darwinn::CreateInstructionBitstream(
      _fbb,
      bitstream__,
      field_offsets__);
}

flatbuffers::Offset<InstructionBitstream> CreateInstructionBitstream(flatbuffers::FlatBufferBuilder &_fbb, const InstructionBitstreamT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DmaDescriptorHintT : public flatbuffers::NativeTable {
  typedef DmaDescriptorHint TableType;
  std::unique_ptr<platforms::darwinn::MetaT> meta;
  int32_t offset_in_bytes;
  int32_t size_in_bytes;
  DmaDescriptorHintT()
      : offset_in_bytes(0),
        size_in_bytes(0) {
  }
};

struct DmaDescriptorHint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DmaDescriptorHintT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_META = 4,
    VT_OFFSET_IN_BYTES = 6,
    VT_SIZE_IN_BYTES = 8
  };
  const platforms::darwinn::Meta *meta() const {
    return GetPointer<const platforms::darwinn::Meta *>(VT_META);
  }
  platforms::darwinn::Meta *mutable_meta() {
    return GetPointer<platforms::darwinn::Meta *>(VT_META);
  }
  int32_t offset_in_bytes() const {
    return GetField<int32_t>(VT_OFFSET_IN_BYTES, 0);
  }
  bool mutate_offset_in_bytes(int32_t _offset_in_bytes) {
    return SetField<int32_t>(VT_OFFSET_IN_BYTES, _offset_in_bytes, 0);
  }
  int32_t size_in_bytes() const {
    return GetField<int32_t>(VT_SIZE_IN_BYTES, 0);
  }
  bool mutate_size_in_bytes(int32_t _size_in_bytes) {
    return SetField<int32_t>(VT_SIZE_IN_BYTES, _size_in_bytes, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_META) &&
           verifier.VerifyTable(meta()) &&
           VerifyField<int32_t>(verifier, VT_OFFSET_IN_BYTES, sizeof(int32_t)) &&
           VerifyField<int32_t>(verifier, VT_SIZE_IN_BYTES, sizeof(int32_t)) &&
           verifier.EndTable();
  }
  DmaDescriptorHintT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DmaDescriptorHintT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DmaDescriptorHint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DmaDescriptorHintT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DmaDescriptorHintBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_meta(flatbuffers::Offset<platforms::darwinn::Meta> meta) {
    fbb_.AddOffset(DmaDescriptorHint::VT_META, meta);
  }
  void add_offset_in_bytes(int32_t offset_in_bytes) {
    fbb_.AddElement<int32_t>(DmaDescriptorHint::VT_OFFSET_IN_BYTES, offset_in_bytes, 0);
  }
  void add_size_in_bytes(int32_t size_in_bytes) {
    fbb_.AddElement<int32_t>(DmaDescriptorHint::VT_SIZE_IN_BYTES, size_in_bytes, 0);
  }
  explicit DmaDescriptorHintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DmaDescriptorHintBuilder &operator=(const DmaDescriptorHintBuilder &);
  flatbuffers::Offset<DmaDescriptorHint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DmaDescriptorHint>(end);
    return o;
  }
};

inline flatbuffers::Offset<DmaDescriptorHint> CreateDmaDescriptorHint(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<platforms::darwinn::Meta> meta = 0,
    int32_t offset_in_bytes = 0,
    int32_t size_in_bytes = 0) {
  DmaDescriptorHintBuilder builder_(_fbb);
  builder_.add_size_in_bytes(size_in_bytes);
  builder_.add_offset_in_bytes(offset_in_bytes);
  builder_.add_meta(meta);
  return builder_.Finish();
}

flatbuffers::Offset<DmaDescriptorHint> CreateDmaDescriptorHint(flatbuffers::FlatBufferBuilder &_fbb, const DmaDescriptorHintT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InterruptHintT : public flatbuffers::NativeTable {
  typedef InterruptHint TableType;
  platforms::darwinn::InterruptType type;
  InterruptHintT()
      : type(platforms::darwinn::InterruptType_SCALAR_CORE_INT_0) {
  }
};

struct InterruptHint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InterruptHintT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  platforms::darwinn::InterruptType type() const {
    return static_cast<platforms::darwinn::InterruptType>(GetField<int16_t>(VT_TYPE, 0));
  }
  bool mutate_type(platforms::darwinn::InterruptType _type) {
    return SetField<int16_t>(VT_TYPE, static_cast<int16_t>(_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE, sizeof(int16_t)) &&
           verifier.EndTable();
  }
  InterruptHintT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InterruptHintT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InterruptHint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InterruptHintT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InterruptHintBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(platforms::darwinn::InterruptType type) {
    fbb_.AddElement<int16_t>(InterruptHint::VT_TYPE, static_cast<int16_t>(type), 0);
  }
  explicit InterruptHintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InterruptHintBuilder &operator=(const InterruptHintBuilder &);
  flatbuffers::Offset<InterruptHint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InterruptHint>(end);
    return o;
  }
};

inline flatbuffers::Offset<InterruptHint> CreateInterruptHint(
    flatbuffers::FlatBufferBuilder &_fbb,
    platforms::darwinn::InterruptType type = platforms::darwinn::InterruptType_SCALAR_CORE_INT_0) {
  InterruptHintBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<InterruptHint> CreateInterruptHint(flatbuffers::FlatBufferBuilder &_fbb, const InterruptHintT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InstructionHintT : public flatbuffers::NativeTable {
  typedef InstructionHint TableType;
  int32_t instruction_chunk_index;
  InstructionHintT()
      : instruction_chunk_index(0) {
  }
};

struct InstructionHint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InstructionHintT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTRUCTION_CHUNK_INDEX = 4
  };
  int32_t instruction_chunk_index() const {
    return GetField<int32_t>(VT_INSTRUCTION_CHUNK_INDEX, 0);
  }
  bool mutate_instruction_chunk_index(int32_t _instruction_chunk_index) {
    return SetField<int32_t>(VT_INSTRUCTION_CHUNK_INDEX, _instruction_chunk_index, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INSTRUCTION_CHUNK_INDEX, sizeof(int32_t)) &&
           verifier.EndTable();
  }
  InstructionHintT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InstructionHintT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InstructionHint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InstructionHintT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InstructionHintBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_instruction_chunk_index(int32_t instruction_chunk_index) {
    fbb_.AddElement<int32_t>(InstructionHint::VT_INSTRUCTION_CHUNK_INDEX, instruction_chunk_index, 0);
  }
  explicit InstructionHintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InstructionHintBuilder &operator=(const InstructionHintBuilder &);
  flatbuffers::Offset<InstructionHint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InstructionHint>(end);
    return o;
  }
};

inline flatbuffers::Offset<InstructionHint> CreateInstructionHint(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t instruction_chunk_index = 0) {
  InstructionHintBuilder builder_(_fbb);
  builder_.add_instruction_chunk_index(instruction_chunk_index);
  return builder_.Finish();
}

flatbuffers::Offset<InstructionHint> CreateInstructionHint(flatbuffers::FlatBufferBuilder &_fbb, const InstructionHintT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FenceHintT : public flatbuffers::NativeTable {
  typedef FenceHint TableType;
  FenceHintT() {
  }
};

struct FenceHint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FenceHintT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FenceHintT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FenceHintT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FenceHint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FenceHintT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FenceHintBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FenceHintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FenceHintBuilder &operator=(const FenceHintBuilder &);
  flatbuffers::Offset<FenceHint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FenceHint>(end);
    return o;
  }
};

inline flatbuffers::Offset<FenceHint> CreateFenceHint(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FenceHintBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<FenceHint> CreateFenceHint(flatbuffers::FlatBufferBuilder &_fbb, const FenceHintT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DmaHintT : public flatbuffers::NativeTable {
  typedef DmaHint TableType;
  platforms::darwinn::AnyHintUnion any_hint;
  platforms::darwinn::Direction direction;
  DmaHintT()
      : direction(platforms::darwinn::Direction_INFEED) {
  }
};

struct DmaHint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DmaHintT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANY_HINT_TYPE = 4,
    VT_ANY_HINT = 6,
    VT_DIRECTION = 8
  };
  platforms::darwinn::AnyHint any_hint_type() const {
    return static_cast<platforms::darwinn::AnyHint>(GetField<uint8_t>(VT_ANY_HINT_TYPE, 0));
  }
  const void *any_hint() const {
    return GetPointer<const void *>(VT_ANY_HINT);
  }
  template<typename T> const T *any_hint_as() const;
  const platforms::darwinn::DmaDescriptorHint *any_hint_as_DmaDescriptorHint() const {
    return any_hint_type() == platforms::darwinn::AnyHint_DmaDescriptorHint ? static_cast<const platforms::darwinn::DmaDescriptorHint *>(any_hint()) : nullptr;
  }
  const platforms::darwinn::InstructionHint *any_hint_as_InstructionHint() const {
    return any_hint_type() == platforms::darwinn::AnyHint_InstructionHint ? static_cast<const platforms::darwinn::InstructionHint *>(any_hint()) : nullptr;
  }
  const platforms::darwinn::InterruptHint *any_hint_as_InterruptHint() const {
    return any_hint_type() == platforms::darwinn::AnyHint_InterruptHint ? static_cast<const platforms::darwinn::InterruptHint *>(any_hint()) : nullptr;
  }
  const platforms::darwinn::FenceHint *any_hint_as_FenceHint() const {
    return any_hint_type() == platforms::darwinn::AnyHint_FenceHint ? static_cast<const platforms::darwinn::FenceHint *>(any_hint()) : nullptr;
  }
  void *mutable_any_hint() {
    return GetPointer<void *>(VT_ANY_HINT);
  }
  platforms::darwinn::Direction direction() const {
    return static_cast<platforms::darwinn::Direction>(GetField<int16_t>(VT_DIRECTION, 0));
  }
  bool mutate_direction(platforms::darwinn::Direction _direction) {
    return SetField<int16_t>(VT_DIRECTION, static_cast<int16_t>(_direction), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ANY_HINT_TYPE, sizeof(uint8_t)) &&
           VerifyOffset(verifier, VT_ANY_HINT) &&
           VerifyAnyHint(verifier, any_hint(), any_hint_type()) &&
           VerifyField<int16_t>(verifier, VT_DIRECTION, sizeof(int16_t)) &&
           verifier.EndTable();
  }
  DmaHintT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DmaHintT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DmaHint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DmaHintT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const platforms::darwinn::DmaDescriptorHint *DmaHint::any_hint_as<platforms::darwinn::DmaDescriptorHint>() const {
  return any_hint_as_DmaDescriptorHint();
}

template<> inline const platforms::darwinn::InstructionHint *DmaHint::any_hint_as<platforms::darwinn::InstructionHint>() const {
  return any_hint_as_InstructionHint();
}

template<> inline const platforms::darwinn::InterruptHint *DmaHint::any_hint_as<platforms::darwinn::InterruptHint>() const {
  return any_hint_as_InterruptHint();
}

template<> inline const platforms::darwinn::FenceHint *DmaHint::any_hint_as<platforms::darwinn::FenceHint>() const {
  return any_hint_as_FenceHint();
}

struct DmaHintBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_any_hint_type(platforms::darwinn::AnyHint any_hint_type) {
    fbb_.AddElement<uint8_t>(DmaHint::VT_ANY_HINT_TYPE, static_cast<uint8_t>(any_hint_type), 0);
  }
  void add_any_hint(flatbuffers::Offset<void> any_hint) {
    fbb_.AddOffset(DmaHint::VT_ANY_HINT, any_hint);
  }
  void add_direction(platforms::darwinn::Direction direction) {
    fbb_.AddElement<int16_t>(DmaHint::VT_DIRECTION, static_cast<int16_t>(direction), 0);
  }
  explicit DmaHintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DmaHintBuilder &operator=(const DmaHintBuilder &);
  flatbuffers::Offset<DmaHint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DmaHint>(end);
    return o;
  }
};

inline flatbuffers::Offset<DmaHint> CreateDmaHint(
    flatbuffers::FlatBufferBuilder &_fbb,
    platforms::darwinn::AnyHint any_hint_type = platforms::darwinn::AnyHint_NONE,
    flatbuffers::Offset<void> any_hint = 0,
    platforms::darwinn::Direction direction = platforms::darwinn::Direction_INFEED) {
  DmaHintBuilder builder_(_fbb);
  builder_.add_any_hint(any_hint);
  builder_.add_direction(direction);
  builder_.add_any_hint_type(any_hint_type);
  return builder_.Finish();
}

flatbuffers::Offset<DmaHint> CreateDmaHint(flatbuffers::FlatBufferBuilder &_fbb, const DmaHintT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DmaHintsT : public flatbuffers::NativeTable {
  typedef DmaHints TableType;
  std::vector<std::unique_ptr<platforms::darwinn::DmaHintT>> hints;
  bool fully_deterministic;
  DmaHintsT()
      : fully_deterministic(false) {
  }
};

struct DmaHints FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DmaHintsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HINTS = 4,
    VT_FULLY_DETERMINISTIC = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::DmaHint>> *hints() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::DmaHint>> *>(VT_HINTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::DmaHint>> *mutable_hints() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::DmaHint>> *>(VT_HINTS);
  }
  bool fully_deterministic() const {
    return GetField<uint8_t>(VT_FULLY_DETERMINISTIC, 0) != 0;
  }
  bool mutate_fully_deterministic(bool _fully_deterministic) {
    return SetField<uint8_t>(VT_FULLY_DETERMINISTIC, static_cast<uint8_t>(_fully_deterministic), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HINTS) &&
           verifier.VerifyVector(hints()) &&
           verifier.VerifyVectorOfTables(hints()) &&
           VerifyField<uint8_t>(verifier, VT_FULLY_DETERMINISTIC, sizeof(uint8_t)) &&
           verifier.EndTable();
  }
  DmaHintsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DmaHintsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DmaHints> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DmaHintsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DmaHintsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hints(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::DmaHint>>> hints) {
    fbb_.AddOffset(DmaHints::VT_HINTS, hints);
  }
  void add_fully_deterministic(bool fully_deterministic) {
    fbb_.AddElement<uint8_t>(DmaHints::VT_FULLY_DETERMINISTIC, static_cast<uint8_t>(fully_deterministic), 0);
  }
  explicit DmaHintsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DmaHintsBuilder &operator=(const DmaHintsBuilder &);
  flatbuffers::Offset<DmaHints> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DmaHints>(end);
    return o;
  }
};

inline flatbuffers::Offset<DmaHints> CreateDmaHints(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::DmaHint>>> hints = 0,
    bool fully_deterministic = false) {
  DmaHintsBuilder builder_(_fbb);
  builder_.add_hints(hints);
  builder_.add_fully_deterministic(fully_deterministic);
  return builder_.Finish();
}

inline flatbuffers::Offset<DmaHints> CreateDmaHintsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<platforms::darwinn::DmaHint>> *hints = nullptr,
    bool fully_deterministic = false) {
  auto hints__ = hints ? _fbb.CreateVector<flatbuffers::Offset<platforms::darwinn::DmaHint>>(*hints) : 0;
  return platforms::darwinn::CreateDmaHints(
      _fbb,
      hints__,
      fully_deterministic);
}

flatbuffers::Offset<DmaHints> CreateDmaHints(flatbuffers::FlatBufferBuilder &_fbb, const DmaHintsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OutputLayoutT : public flatbuffers::NativeTable {
  typedef OutputLayout TableType;
  std::vector<int32_t> y_coordinate_to_linear_tile_id_map;
  std::vector<int32_t> x_coordinate_to_linear_tile_id_map;
  std::vector<int32_t> linearized_tile_byte_offset;
  std::vector<int32_t> x_coordinate_to_local_byte_offset;
  std::vector<int32_t> y_coordinate_to_local_y_offset;
  std::vector<int32_t> x_coordinate_to_local_y_row_size;
  OutputLayoutT() {
  }
};

struct OutputLayout FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OutputLayoutT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_Y_COORDINATE_TO_LINEAR_TILE_ID_MAP = 4,
    VT_X_COORDINATE_TO_LINEAR_TILE_ID_MAP = 6,
    VT_LINEARIZED_TILE_BYTE_OFFSET = 8,
    VT_X_COORDINATE_TO_LOCAL_BYTE_OFFSET = 10,
    VT_Y_COORDINATE_TO_LOCAL_Y_OFFSET = 12,
    VT_X_COORDINATE_TO_LOCAL_Y_ROW_SIZE = 14
  };
  const flatbuffers::Vector<int32_t> *y_coordinate_to_linear_tile_id_map() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_Y_COORDINATE_TO_LINEAR_TILE_ID_MAP);
  }
  flatbuffers::Vector<int32_t> *mutable_y_coordinate_to_linear_tile_id_map() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_Y_COORDINATE_TO_LINEAR_TILE_ID_MAP);
  }
  const flatbuffers::Vector<int32_t> *x_coordinate_to_linear_tile_id_map() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_X_COORDINATE_TO_LINEAR_TILE_ID_MAP);
  }
  flatbuffers::Vector<int32_t> *mutable_x_coordinate_to_linear_tile_id_map() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_X_COORDINATE_TO_LINEAR_TILE_ID_MAP);
  }
  const flatbuffers::Vector<int32_t> *linearized_tile_byte_offset() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_LINEARIZED_TILE_BYTE_OFFSET);
  }
  flatbuffers::Vector<int32_t> *mutable_linearized_tile_byte_offset() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_LINEARIZED_TILE_BYTE_OFFSET);
  }
  const flatbuffers::Vector<int32_t> *x_coordinate_to_local_byte_offset() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_X_COORDINATE_TO_LOCAL_BYTE_OFFSET);
  }
  flatbuffers::Vector<int32_t> *mutable_x_coordinate_to_local_byte_offset() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_X_COORDINATE_TO_LOCAL_BYTE_OFFSET);
  }
  const flatbuffers::Vector<int32_t> *y_coordinate_to_local_y_offset() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_Y_COORDINATE_TO_LOCAL_Y_OFFSET);
  }
  flatbuffers::Vector<int32_t> *mutable_y_coordinate_to_local_y_offset() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_Y_COORDINATE_TO_LOCAL_Y_OFFSET);
  }
  const flatbuffers::Vector<int32_t> *x_coordinate_to_local_y_row_size() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_X_COORDINATE_TO_LOCAL_Y_ROW_SIZE);
  }
  flatbuffers::Vector<int32_t> *mutable_x_coordinate_to_local_y_row_size() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_X_COORDINATE_TO_LOCAL_Y_ROW_SIZE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_Y_COORDINATE_TO_LINEAR_TILE_ID_MAP) &&
           verifier.VerifyVector(y_coordinate_to_linear_tile_id_map()) &&
           VerifyOffset(verifier, VT_X_COORDINATE_TO_LINEAR_TILE_ID_MAP) &&
           verifier.VerifyVector(x_coordinate_to_linear_tile_id_map()) &&
           VerifyOffset(verifier, VT_LINEARIZED_TILE_BYTE_OFFSET) &&
           verifier.VerifyVector(linearized_tile_byte_offset()) &&
           VerifyOffset(verifier, VT_X_COORDINATE_TO_LOCAL_BYTE_OFFSET) &&
           verifier.VerifyVector(x_coordinate_to_local_byte_offset()) &&
           VerifyOffset(verifier, VT_Y_COORDINATE_TO_LOCAL_Y_OFFSET) &&
           verifier.VerifyVector(y_coordinate_to_local_y_offset()) &&
           VerifyOffset(verifier, VT_X_COORDINATE_TO_LOCAL_Y_ROW_SIZE) &&
           verifier.VerifyVector(x_coordinate_to_local_y_row_size()) &&
           verifier.EndTable();
  }
  OutputLayoutT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OutputLayoutT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OutputLayout> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OutputLayoutT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OutputLayoutBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_y_coordinate_to_linear_tile_id_map(flatbuffers::Offset<flatbuffers::Vector<int32_t>> y_coordinate_to_linear_tile_id_map) {
    fbb_.AddOffset(OutputLayout::VT_Y_COORDINATE_TO_LINEAR_TILE_ID_MAP, y_coordinate_to_linear_tile_id_map);
  }
  void add_x_coordinate_to_linear_tile_id_map(flatbuffers::Offset<flatbuffers::Vector<int32_t>> x_coordinate_to_linear_tile_id_map) {
    fbb_.AddOffset(OutputLayout::VT_X_COORDINATE_TO_LINEAR_TILE_ID_MAP, x_coordinate_to_linear_tile_id_map);
  }
  void add_linearized_tile_byte_offset(flatbuffers::Offset<flatbuffers::Vector<int32_t>> linearized_tile_byte_offset) {
    fbb_.AddOffset(OutputLayout::VT_LINEARIZED_TILE_BYTE_OFFSET, linearized_tile_byte_offset);
  }
  void add_x_coordinate_to_local_byte_offset(flatbuffers::Offset<flatbuffers::Vector<int32_t>> x_coordinate_to_local_byte_offset) {
    fbb_.AddOffset(OutputLayout::VT_X_COORDINATE_TO_LOCAL_BYTE_OFFSET, x_coordinate_to_local_byte_offset);
  }
  void add_y_coordinate_to_local_y_offset(flatbuffers::Offset<flatbuffers::Vector<int32_t>> y_coordinate_to_local_y_offset) {
    fbb_.AddOffset(OutputLayout::VT_Y_COORDINATE_TO_LOCAL_Y_OFFSET, y_coordinate_to_local_y_offset);
  }
  void add_x_coordinate_to_local_y_row_size(flatbuffers::Offset<flatbuffers::Vector<int32_t>> x_coordinate_to_local_y_row_size) {
    fbb_.AddOffset(OutputLayout::VT_X_COORDINATE_TO_LOCAL_Y_ROW_SIZE, x_coordinate_to_local_y_row_size);
  }
  explicit OutputLayoutBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OutputLayoutBuilder &operator=(const OutputLayoutBuilder &);
  flatbuffers::Offset<OutputLayout> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OutputLayout>(end);
    return o;
  }
};

inline flatbuffers::Offset<OutputLayout> CreateOutputLayout(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> y_coordinate_to_linear_tile_id_map = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> x_coordinate_to_linear_tile_id_map = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> linearized_tile_byte_offset = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> x_coordinate_to_local_byte_offset = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> y_coordinate_to_local_y_offset = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> x_coordinate_to_local_y_row_size = 0) {
  OutputLayoutBuilder builder_(_fbb);
  builder_.add_x_coordinate_to_local_y_row_size(x_coordinate_to_local_y_row_size);
  builder_.add_y_coordinate_to_local_y_offset(y_coordinate_to_local_y_offset);
  builder_.add_x_coordinate_to_local_byte_offset(x_coordinate_to_local_byte_offset);
  builder_.add_linearized_tile_byte_offset(linearized_tile_byte_offset);
  builder_.add_x_coordinate_to_linear_tile_id_map(x_coordinate_to_linear_tile_id_map);
  builder_.add_y_coordinate_to_linear_tile_id_map(y_coordinate_to_linear_tile_id_map);
  return builder_.Finish();
}

inline flatbuffers::Offset<OutputLayout> CreateOutputLayoutDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *y_coordinate_to_linear_tile_id_map = nullptr,
    const std::vector<int32_t> *x_coordinate_to_linear_tile_id_map = nullptr,
    const std::vector<int32_t> *linearized_tile_byte_offset = nullptr,
    const std::vector<int32_t> *x_coordinate_to_local_byte_offset = nullptr,
    const std::vector<int32_t> *y_coordinate_to_local_y_offset = nullptr,
    const std::vector<int32_t> *x_coordinate_to_local_y_row_size = nullptr) {
  auto y_coordinate_to_linear_tile_id_map__ = y_coordinate_to_linear_tile_id_map ? _fbb.CreateVector<int32_t>(*y_coordinate_to_linear_tile_id_map) : 0;
  auto x_coordinate_to_linear_tile_id_map__ = x_coordinate_to_linear_tile_id_map ? _fbb.CreateVector<int32_t>(*x_coordinate_to_linear_tile_id_map) : 0;
  auto linearized_tile_byte_offset__ = linearized_tile_byte_offset ? _fbb.CreateVector<int32_t>(*linearized_tile_byte_offset) : 0;
  auto x_coordinate_to_local_byte_offset__ = x_coordinate_to_local_byte_offset ? _fbb.CreateVector<int32_t>(*x_coordinate_to_local_byte_offset) : 0;
  auto y_coordinate_to_local_y_offset__ = y_coordinate_to_local_y_offset ? _fbb.CreateVector<int32_t>(*y_coordinate_to_local_y_offset) : 0;
  auto x_coordinate_to_local_y_row_size__ = x_coordinate_to_local_y_row_size ? _fbb.CreateVector<int32_t>(*x_coordinate_to_local_y_row_size) : 0;
  return platforms::darwinn::CreateOutputLayout(
      _fbb,
      y_coordinate_to_linear_tile_id_map__,
      x_coordinate_to_linear_tile_id_map__,
      linearized_tile_byte_offset__,
      x_coordinate_to_local_byte_offset__,
      y_coordinate_to_local_y_offset__,
      x_coordinate_to_local_y_row_size__);
}

flatbuffers::Offset<OutputLayout> CreateOutputLayout(flatbuffers::FlatBufferBuilder &_fbb, const OutputLayoutT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorShapeT : public flatbuffers::NativeTable {
  typedef TensorShape TableType;
  std::vector<platforms::darwinn::Range> dimension;
  TensorShapeT() {
  }
};

struct TensorShape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorShapeT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMENSION = 4
  };
  const flatbuffers::Vector<const platforms::darwinn::Range *> *dimension() const {
    return GetPointer<const flatbuffers::Vector<const platforms::darwinn::Range *> *>(VT_DIMENSION);
  }
  flatbuffers::Vector<const platforms::darwinn::Range *> *mutable_dimension() {
    return GetPointer<flatbuffers::Vector<const platforms::darwinn::Range *> *>(VT_DIMENSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMENSION) &&
           verifier.VerifyVector(dimension()) &&
           verifier.EndTable();
  }
  TensorShapeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorShapeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorShape> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorShapeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorShapeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dimension(flatbuffers::Offset<flatbuffers::Vector<const platforms::darwinn::Range *>> dimension) {
    fbb_.AddOffset(TensorShape::VT_DIMENSION, dimension);
  }
  explicit TensorShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorShapeBuilder &operator=(const TensorShapeBuilder &);
  flatbuffers::Offset<TensorShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorShape>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorShape> CreateTensorShape(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const platforms::darwinn::Range *>> dimension = 0) {
  TensorShapeBuilder builder_(_fbb);
  builder_.add_dimension(dimension);
  return builder_.Finish();
}

inline flatbuffers::Offset<TensorShape> CreateTensorShapeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<platforms::darwinn::Range> *dimension = nullptr) {
  auto dimension__ = dimension ? _fbb.CreateVectorOfStructs<platforms::darwinn::Range>(*dimension) : 0;
  return platforms::darwinn::CreateTensorShape(
      _fbb,
      dimension__);
}

flatbuffers::Offset<TensorShape> CreateTensorShape(flatbuffers::FlatBufferBuilder &_fbb, const TensorShapeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorLayoutT : public flatbuffers::NativeTable {
  typedef TensorLayout TableType;
  std::unique_ptr<platforms::darwinn::TensorShapeT> shape;
  std::vector<int32_t> stride;
  TensorLayoutT() {
  }
};

struct TensorLayout FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorLayoutT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE = 4,
    VT_STRIDE = 6
  };
  const platforms::darwinn::TensorShape *shape() const {
    return GetPointer<const platforms::darwinn::TensorShape *>(VT_SHAPE);
  }
  platforms::darwinn::TensorShape *mutable_shape() {
    return GetPointer<platforms::darwinn::TensorShape *>(VT_SHAPE);
  }
  const flatbuffers::Vector<int32_t> *stride() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDE);
  }
  flatbuffers::Vector<int32_t> *mutable_stride() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_STRIDE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyTable(shape()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           verifier.EndTable();
  }
  TensorLayoutT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorLayoutT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorLayout> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorLayoutT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorLayoutBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape(flatbuffers::Offset<platforms::darwinn::TensorShape> shape) {
    fbb_.AddOffset(TensorLayout::VT_SHAPE, shape);
  }
  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int32_t>> stride) {
    fbb_.AddOffset(TensorLayout::VT_STRIDE, stride);
  }
  explicit TensorLayoutBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorLayoutBuilder &operator=(const TensorLayoutBuilder &);
  flatbuffers::Offset<TensorLayout> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorLayout>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorLayout> CreateTensorLayout(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<platforms::darwinn::TensorShape> shape = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> stride = 0) {
  TensorLayoutBuilder builder_(_fbb);
  builder_.add_stride(stride);
  builder_.add_shape(shape);
  return builder_.Finish();
}

inline flatbuffers::Offset<TensorLayout> CreateTensorLayoutDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<platforms::darwinn::TensorShape> shape = 0,
    const std::vector<int32_t> *stride = nullptr) {
  auto stride__ = stride ? _fbb.CreateVector<int32_t>(*stride) : 0;
  return platforms::darwinn::CreateTensorLayout(
      _fbb,
      shape,
      stride__);
}

flatbuffers::Offset<TensorLayout> CreateTensorLayout(flatbuffers::FlatBufferBuilder &_fbb, const TensorLayoutT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OutputShapeInfoT : public flatbuffers::NativeTable {
  typedef OutputShapeInfo TableType;
  std::vector<std::unique_ptr<platforms::darwinn::TensorLayoutT>> slice_layout;
  std::vector<int32_t> slice_offset;
  OutputShapeInfoT() {
  }
};

struct OutputShapeInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OutputShapeInfoT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SLICE_LAYOUT = 4,
    VT_SLICE_OFFSET = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::TensorLayout>> *slice_layout() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::TensorLayout>> *>(VT_SLICE_LAYOUT);
  }
  flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::TensorLayout>> *mutable_slice_layout() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::TensorLayout>> *>(VT_SLICE_LAYOUT);
  }
  const flatbuffers::Vector<int32_t> *slice_offset() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SLICE_OFFSET);
  }
  flatbuffers::Vector<int32_t> *mutable_slice_offset() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_SLICE_OFFSET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SLICE_LAYOUT) &&
           verifier.VerifyVector(slice_layout()) &&
           verifier.VerifyVectorOfTables(slice_layout()) &&
           VerifyOffset(verifier, VT_SLICE_OFFSET) &&
           verifier.VerifyVector(slice_offset()) &&
           verifier.EndTable();
  }
  OutputShapeInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OutputShapeInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OutputShapeInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OutputShapeInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OutputShapeInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slice_layout(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::TensorLayout>>> slice_layout) {
    fbb_.AddOffset(OutputShapeInfo::VT_SLICE_LAYOUT, slice_layout);
  }
  void add_slice_offset(flatbuffers::Offset<flatbuffers::Vector<int32_t>> slice_offset) {
    fbb_.AddOffset(OutputShapeInfo::VT_SLICE_OFFSET, slice_offset);
  }
  explicit OutputShapeInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OutputShapeInfoBuilder &operator=(const OutputShapeInfoBuilder &);
  flatbuffers::Offset<OutputShapeInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OutputShapeInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<OutputShapeInfo> CreateOutputShapeInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::TensorLayout>>> slice_layout = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> slice_offset = 0) {
  OutputShapeInfoBuilder builder_(_fbb);
  builder_.add_slice_offset(slice_offset);
  builder_.add_slice_layout(slice_layout);
  return builder_.Finish();
}

inline flatbuffers::Offset<OutputShapeInfo> CreateOutputShapeInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<platforms::darwinn::TensorLayout>> *slice_layout = nullptr,
    const std::vector<int32_t> *slice_offset = nullptr) {
  auto slice_layout__ = slice_layout ? _fbb.CreateVector<flatbuffers::Offset<platforms::darwinn::TensorLayout>>(*slice_layout) : 0;
  auto slice_offset__ = slice_offset ? _fbb.CreateVector<int32_t>(*slice_offset) : 0;
  return platforms::darwinn::CreateOutputShapeInfo(
      _fbb,
      slice_layout__,
      slice_offset__);
}

flatbuffers::Offset<OutputShapeInfo> CreateOutputShapeInfo(flatbuffers::FlatBufferBuilder &_fbb, const OutputShapeInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NumericsConstantsT : public flatbuffers::NativeTable {
  typedef NumericsConstants TableType;
  int32_t zero_point;
  float dequantization_factor;
  NumericsConstantsT()
      : zero_point(0),
        dequantization_factor(0.0f) {
  }
};

struct NumericsConstants FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NumericsConstantsT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ZERO_POINT = 4,
    VT_DEQUANTIZATION_FACTOR = 6
  };
  int32_t zero_point() const {
    return GetField<int32_t>(VT_ZERO_POINT, 0);
  }
  bool mutate_zero_point(int32_t _zero_point) {
    return SetField<int32_t>(VT_ZERO_POINT, _zero_point, 0);
  }
  float dequantization_factor() const {
    return GetField<float>(VT_DEQUANTIZATION_FACTOR, 0.0f);
  }
  bool mutate_dequantization_factor(float _dequantization_factor) {
    return SetField<float>(VT_DEQUANTIZATION_FACTOR, _dequantization_factor, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ZERO_POINT, sizeof(int32_t)) &&
           VerifyField<float>(verifier, VT_DEQUANTIZATION_FACTOR, sizeof(float)) &&
           verifier.EndTable();
  }
  NumericsConstantsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NumericsConstantsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NumericsConstants> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NumericsConstantsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NumericsConstantsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_zero_point(int32_t zero_point) {
    fbb_.AddElement<int32_t>(NumericsConstants::VT_ZERO_POINT, zero_point, 0);
  }
  void add_dequantization_factor(float dequantization_factor) {
    fbb_.AddElement<float>(NumericsConstants::VT_DEQUANTIZATION_FACTOR, dequantization_factor, 0.0f);
  }
  explicit NumericsConstantsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NumericsConstantsBuilder &operator=(const NumericsConstantsBuilder &);
  flatbuffers::Offset<NumericsConstants> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NumericsConstants>(end);
    return o;
  }
};

inline flatbuffers::Offset<NumericsConstants> CreateNumericsConstants(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t zero_point = 0,
    float dequantization_factor = 0.0f) {
  NumericsConstantsBuilder builder_(_fbb);
  builder_.add_dequantization_factor(dequantization_factor);
  builder_.add_zero_point(zero_point);
  return builder_.Finish();
}

flatbuffers::Offset<NumericsConstants> CreateNumericsConstants(flatbuffers::FlatBufferBuilder &_fbb, const NumericsConstantsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OutputLayerT : public flatbuffers::NativeTable {
  typedef OutputLayer TableType;
  std::unique_ptr<platforms::darwinn::OutputLayoutT> layout;
  platforms::darwinn::DataType data_type;
  std::unique_ptr<platforms::darwinn::OutputShapeInfoT> shape_info;
  OutputLayerT()
      : data_type(platforms::darwinn::DataType_FIXED_POINT8) {
  }
};

struct OutputLayer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OutputLayerT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LAYOUT = 4,
    VT_DATA_TYPE = 6,
    VT_SHAPE_INFO = 8
  };
  const platforms::darwinn::OutputLayout *layout() const {
    return GetPointer<const platforms::darwinn::OutputLayout *>(VT_LAYOUT);
  }
  platforms::darwinn::OutputLayout *mutable_layout() {
    return GetPointer<platforms::darwinn::OutputLayout *>(VT_LAYOUT);
  }
  platforms::darwinn::DataType data_type() const {
    return static_cast<platforms::darwinn::DataType>(GetField<int16_t>(VT_DATA_TYPE, 0));
  }
  bool mutate_data_type(platforms::darwinn::DataType _data_type) {
    return SetField<int16_t>(VT_DATA_TYPE, static_cast<int16_t>(_data_type), 0);
  }
  const platforms::darwinn::OutputShapeInfo *shape_info() const {
    return GetPointer<const platforms::darwinn::OutputShapeInfo *>(VT_SHAPE_INFO);
  }
  platforms::darwinn::OutputShapeInfo *mutable_shape_info() {
    return GetPointer<platforms::darwinn::OutputShapeInfo *>(VT_SHAPE_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LAYOUT) &&
           verifier.VerifyTable(layout()) &&
           VerifyField<int16_t>(verifier, VT_DATA_TYPE, sizeof(int16_t)) &&
           VerifyOffset(verifier, VT_SHAPE_INFO) &&
           verifier.VerifyTable(shape_info()) &&
           verifier.EndTable();
  }
  OutputLayerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OutputLayerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OutputLayer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OutputLayerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OutputLayerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_layout(flatbuffers::Offset<platforms::darwinn::OutputLayout> layout) {
    fbb_.AddOffset(OutputLayer::VT_LAYOUT, layout);
  }
  void add_data_type(platforms::darwinn::DataType data_type) {
    fbb_.AddElement<int16_t>(OutputLayer::VT_DATA_TYPE, static_cast<int16_t>(data_type), 0);
  }
  void add_shape_info(flatbuffers::Offset<platforms::darwinn::OutputShapeInfo> shape_info) {
    fbb_.AddOffset(OutputLayer::VT_SHAPE_INFO, shape_info);
  }
  explicit OutputLayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OutputLayerBuilder &operator=(const OutputLayerBuilder &);
  flatbuffers::Offset<OutputLayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OutputLayer>(end);
    return o;
  }
};

inline flatbuffers::Offset<OutputLayer> CreateOutputLayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<platforms::darwinn::OutputLayout> layout = 0,
    platforms::darwinn::DataType data_type = platforms::darwinn::DataType_FIXED_POINT8,
    flatbuffers::Offset<platforms::darwinn::OutputShapeInfo> shape_info = 0) {
  OutputLayerBuilder builder_(_fbb);
  builder_.add_shape_info(shape_info);
  builder_.add_layout(layout);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

flatbuffers::Offset<OutputLayer> CreateOutputLayer(flatbuffers::FlatBufferBuilder &_fbb, const OutputLayerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InputLayerT : public flatbuffers::NativeTable {
  typedef InputLayer TableType;
  InputLayerT() {
  }
};

struct InputLayer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputLayerT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  InputLayerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InputLayerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InputLayer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputLayerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InputLayerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit InputLayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InputLayerBuilder &operator=(const InputLayerBuilder &);
  flatbuffers::Offset<InputLayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InputLayer>(end);
    return o;
  }
};

inline flatbuffers::Offset<InputLayer> CreateInputLayer(
    flatbuffers::FlatBufferBuilder &_fbb) {
  InputLayerBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<InputLayer> CreateInputLayer(flatbuffers::FlatBufferBuilder &_fbb, const InputLayerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LayerT : public flatbuffers::NativeTable {
  typedef Layer TableType;
  std::string name;
  int32_t size_bytes;
  int32_t y_dim;
  int32_t x_dim;
  int32_t z_dim;
  std::unique_ptr<platforms::darwinn::NumericsConstantsT> numerics;
  platforms::darwinn::DataType data_type;
  platforms::darwinn::AnyLayerUnion any_layer;
  int32_t execution_count_per_inference;
  bool cache_on_dram;
  std::unique_ptr<platforms::darwinn::TensorShapeT> shape;
  LayerT()
      : size_bytes(0),
        y_dim(0),
        x_dim(0),
        z_dim(0),
        data_type(platforms::darwinn::DataType_FIXED_POINT8),
        execution_count_per_inference(1),
        cache_on_dram(false) {
  }
};

struct Layer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LayerT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SIZE_BYTES = 6,
    VT_Y_DIM = 8,
    VT_X_DIM = 10,
    VT_Z_DIM = 12,
    VT_NUMERICS = 14,
    VT_DATA_TYPE = 16,
    VT_ANY_LAYER_TYPE = 18,
    VT_ANY_LAYER = 20,
    VT_EXECUTION_COUNT_PER_INFERENCE = 22,
    VT_CACHE_ON_DRAM = 24,
    VT_SHAPE = 26
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  int32_t size_bytes() const {
    return GetField<int32_t>(VT_SIZE_BYTES, 0);
  }
  bool mutate_size_bytes(int32_t _size_bytes) {
    return SetField<int32_t>(VT_SIZE_BYTES, _size_bytes, 0);
  }
  int32_t y_dim() const {
    return GetField<int32_t>(VT_Y_DIM, 0);
  }
  bool mutate_y_dim(int32_t _y_dim) {
    return SetField<int32_t>(VT_Y_DIM, _y_dim, 0);
  }
  int32_t x_dim() const {
    return GetField<int32_t>(VT_X_DIM, 0);
  }
  bool mutate_x_dim(int32_t _x_dim) {
    return SetField<int32_t>(VT_X_DIM, _x_dim, 0);
  }
  int32_t z_dim() const {
    return GetField<int32_t>(VT_Z_DIM, 0);
  }
  bool mutate_z_dim(int32_t _z_dim) {
    return SetField<int32_t>(VT_Z_DIM, _z_dim, 0);
  }
  const platforms::darwinn::NumericsConstants *numerics() const {
    return GetPointer<const platforms::darwinn::NumericsConstants *>(VT_NUMERICS);
  }
  platforms::darwinn::NumericsConstants *mutable_numerics() {
    return GetPointer<platforms::darwinn::NumericsConstants *>(VT_NUMERICS);
  }
  platforms::darwinn::DataType data_type() const {
    return static_cast<platforms::darwinn::DataType>(GetField<int16_t>(VT_DATA_TYPE, 0));
  }
  bool mutate_data_type(platforms::darwinn::DataType _data_type) {
    return SetField<int16_t>(VT_DATA_TYPE, static_cast<int16_t>(_data_type), 0);
  }
  platforms::darwinn::AnyLayer any_layer_type() const {
    return static_cast<platforms::darwinn::AnyLayer>(GetField<uint8_t>(VT_ANY_LAYER_TYPE, 0));
  }
  const void *any_layer() const {
    return GetPointer<const void *>(VT_ANY_LAYER);
  }
  template<typename T> const T *any_layer_as() const;
  const platforms::darwinn::OutputLayer *any_layer_as_OutputLayer() const {
    return any_layer_type() == platforms::darwinn::AnyLayer_OutputLayer ? static_cast<const platforms::darwinn::OutputLayer *>(any_layer()) : nullptr;
  }
  const platforms::darwinn::InputLayer *any_layer_as_InputLayer() const {
    return any_layer_type() == platforms::darwinn::AnyLayer_InputLayer ? static_cast<const platforms::darwinn::InputLayer *>(any_layer()) : nullptr;
  }
  void *mutable_any_layer() {
    return GetPointer<void *>(VT_ANY_LAYER);
  }
  int32_t execution_count_per_inference() const {
    return GetField<int32_t>(VT_EXECUTION_COUNT_PER_INFERENCE, 1);
  }
  bool mutate_execution_count_per_inference(int32_t _execution_count_per_inference) {
    return SetField<int32_t>(VT_EXECUTION_COUNT_PER_INFERENCE, _execution_count_per_inference, 1);
  }
  bool cache_on_dram() const {
    return GetField<uint8_t>(VT_CACHE_ON_DRAM, 0) != 0;
  }
  bool mutate_cache_on_dram(bool _cache_on_dram) {
    return SetField<uint8_t>(VT_CACHE_ON_DRAM, static_cast<uint8_t>(_cache_on_dram), 0);
  }
  const platforms::darwinn::TensorShape *shape() const {
    return GetPointer<const platforms::darwinn::TensorShape *>(VT_SHAPE);
  }
  platforms::darwinn::TensorShape *mutable_shape() {
    return GetPointer<platforms::darwinn::TensorShape *>(VT_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_SIZE_BYTES, sizeof(int32_t)) &&
           VerifyField<int32_t>(verifier, VT_Y_DIM, sizeof(int32_t)) &&
           VerifyField<int32_t>(verifier, VT_X_DIM, sizeof(int32_t)) &&
           VerifyField<int32_t>(verifier, VT_Z_DIM, sizeof(int32_t)) &&
           VerifyOffset(verifier, VT_NUMERICS) &&
           verifier.VerifyTable(numerics()) &&
           VerifyField<int16_t>(verifier, VT_DATA_TYPE, sizeof(int16_t)) &&
           VerifyField<uint8_t>(verifier, VT_ANY_LAYER_TYPE, sizeof(uint8_t)) &&
           VerifyOffset(verifier, VT_ANY_LAYER) &&
           VerifyAnyLayer(verifier, any_layer(), any_layer_type()) &&
           VerifyField<int32_t>(verifier, VT_EXECUTION_COUNT_PER_INFERENCE, sizeof(int32_t)) &&
           VerifyField<uint8_t>(verifier, VT_CACHE_ON_DRAM, sizeof(uint8_t)) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyTable(shape()) &&
           verifier.EndTable();
  }
  LayerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LayerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Layer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LayerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const platforms::darwinn::OutputLayer *Layer::any_layer_as<platforms::darwinn::OutputLayer>() const {
  return any_layer_as_OutputLayer();
}

template<> inline const platforms::darwinn::InputLayer *Layer::any_layer_as<platforms::darwinn::InputLayer>() const {
  return any_layer_as_InputLayer();
}

struct LayerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Layer::VT_NAME, name);
  }
  void add_size_bytes(int32_t size_bytes) {
    fbb_.AddElement<int32_t>(Layer::VT_SIZE_BYTES, size_bytes, 0);
  }
  void add_y_dim(int32_t y_dim) {
    fbb_.AddElement<int32_t>(Layer::VT_Y_DIM, y_dim, 0);
  }
  void add_x_dim(int32_t x_dim) {
    fbb_.AddElement<int32_t>(Layer::VT_X_DIM, x_dim, 0);
  }
  void add_z_dim(int32_t z_dim) {
    fbb_.AddElement<int32_t>(Layer::VT_Z_DIM, z_dim, 0);
  }
  void add_numerics(flatbuffers::Offset<platforms::darwinn::NumericsConstants> numerics) {
    fbb_.AddOffset(Layer::VT_NUMERICS, numerics);
  }
  void add_data_type(platforms::darwinn::DataType data_type) {
    fbb_.AddElement<int16_t>(Layer::VT_DATA_TYPE, static_cast<int16_t>(data_type), 0);
  }
  void add_any_layer_type(platforms::darwinn::AnyLayer any_layer_type) {
    fbb_.AddElement<uint8_t>(Layer::VT_ANY_LAYER_TYPE, static_cast<uint8_t>(any_layer_type), 0);
  }
  void add_any_layer(flatbuffers::Offset<void> any_layer) {
    fbb_.AddOffset(Layer::VT_ANY_LAYER, any_layer);
  }
  void add_execution_count_per_inference(int32_t execution_count_per_inference) {
    fbb_.AddElement<int32_t>(Layer::VT_EXECUTION_COUNT_PER_INFERENCE, execution_count_per_inference, 1);
  }
  void add_cache_on_dram(bool cache_on_dram) {
    fbb_.AddElement<uint8_t>(Layer::VT_CACHE_ON_DRAM, static_cast<uint8_t>(cache_on_dram), 0);
  }
  void add_shape(flatbuffers::Offset<platforms::darwinn::TensorShape> shape) {
    fbb_.AddOffset(Layer::VT_SHAPE, shape);
  }
  explicit LayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LayerBuilder &operator=(const LayerBuilder &);
  flatbuffers::Offset<Layer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Layer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Layer> CreateLayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t size_bytes = 0,
    int32_t y_dim = 0,
    int32_t x_dim = 0,
    int32_t z_dim = 0,
    flatbuffers::Offset<platforms::darwinn::NumericsConstants> numerics = 0,
    platforms::darwinn::DataType data_type = platforms::darwinn::DataType_FIXED_POINT8,
    platforms::darwinn::AnyLayer any_layer_type = platforms::darwinn::AnyLayer_NONE,
    flatbuffers::Offset<void> any_layer = 0,
    int32_t execution_count_per_inference = 1,
    bool cache_on_dram = false,
    flatbuffers::Offset<platforms::darwinn::TensorShape> shape = 0) {
  LayerBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_execution_count_per_inference(execution_count_per_inference);
  builder_.add_any_layer(any_layer);
  builder_.add_numerics(numerics);
  builder_.add_z_dim(z_dim);
  builder_.add_x_dim(x_dim);
  builder_.add_y_dim(y_dim);
  builder_.add_size_bytes(size_bytes);
  builder_.add_name(name);
  builder_.add_data_type(data_type);
  builder_.add_cache_on_dram(cache_on_dram);
  builder_.add_any_layer_type(any_layer_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Layer> CreateLayerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t size_bytes = 0,
    int32_t y_dim = 0,
    int32_t x_dim = 0,
    int32_t z_dim = 0,
    flatbuffers::Offset<platforms::darwinn::NumericsConstants> numerics = 0,
    platforms::darwinn::DataType data_type = platforms::darwinn::DataType_FIXED_POINT8,
    platforms::darwinn::AnyLayer any_layer_type = platforms::darwinn::AnyLayer_NONE,
    flatbuffers::Offset<void> any_layer = 0,
    int32_t execution_count_per_inference = 1,
    bool cache_on_dram = false,
    flatbuffers::Offset<platforms::darwinn::TensorShape> shape = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return platforms::darwinn::CreateLayer(
      _fbb,
      name__,
      size_bytes,
      y_dim,
      x_dim,
      z_dim,
      numerics,
      data_type,
      any_layer_type,
      any_layer,
      execution_count_per_inference,
      cache_on_dram,
      shape);
}

flatbuffers::Offset<Layer> CreateLayer(flatbuffers::FlatBufferBuilder &_fbb, const LayerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExecutableT : public flatbuffers::NativeTable {
  typedef Executable TableType;
  int32_t version;
  std::string name;
  std::vector<uint8_t> serialized_model;
  int32_t batch_size;
  int32_t scratch_size_bytes;
  std::vector<std::unique_ptr<platforms::darwinn::InstructionBitstreamT>> instruction_bitstreams;
  std::vector<uint8_t> parameters;
  std::unique_ptr<platforms::darwinn::DmaHintsT> dma_hints;
  std::vector<std::unique_ptr<platforms::darwinn::LayerT>> input_layers;
  std::vector<std::unique_ptr<platforms::darwinn::LayerT>> output_layers;
  std::string chip;
  int32_t estimated_cycles;
  int32_t used_narrow_memory_bytes_per_tile;
  platforms::darwinn::ExecutableType type;
  uint64_t parameter_caching_token;
  bool use_tpu_dram_for_parameters;
  int64_t estimated_cycles_64bit;
  ExecutableT()
      : version(0),
        batch_size(0),
        scratch_size_bytes(0),
        estimated_cycles(0),
        used_narrow_memory_bytes_per_tile(0),
        type(platforms::darwinn::ExecutableType_STAND_ALONE),
        parameter_caching_token(0),
        use_tpu_dram_for_parameters(false),
        estimated_cycles_64bit(0) {
  }
};

struct Executable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExecutableT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_NAME = 6,
    VT_SERIALIZED_MODEL = 8,
    VT_BATCH_SIZE = 10,
    VT_SCRATCH_SIZE_BYTES = 12,
    VT_INSTRUCTION_BITSTREAMS = 14,
    VT_PARAMETERS = 16,
    VT_DMA_HINTS = 18,
    VT_INPUT_LAYERS = 20,
    VT_OUTPUT_LAYERS = 22,
    VT_CHIP = 24,
    VT_ESTIMATED_CYCLES = 26,
    VT_USED_NARROW_MEMORY_BYTES_PER_TILE = 28,
    VT_TYPE = 30,
    VT_PARAMETER_CACHING_TOKEN = 32,
    VT_USE_TPU_DRAM_FOR_PARAMETERS = 34,
    VT_ESTIMATED_CYCLES_64BIT = 36
  };
  int32_t version() const {
    return GetField<int32_t>(VT_VERSION, 0);
  }
  bool mutate_version(int32_t _version) {
    return SetField<int32_t>(VT_VERSION, _version, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint8_t> *serialized_model() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SERIALIZED_MODEL);
  }
  flatbuffers::Vector<uint8_t> *mutable_serialized_model() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_SERIALIZED_MODEL);
  }
  int32_t batch_size() const {
    return GetField<int32_t>(VT_BATCH_SIZE, 0);
  }
  bool mutate_batch_size(int32_t _batch_size) {
    return SetField<int32_t>(VT_BATCH_SIZE, _batch_size, 0);
  }
  int32_t scratch_size_bytes() const {
    return GetField<int32_t>(VT_SCRATCH_SIZE_BYTES, 0);
  }
  bool mutate_scratch_size_bytes(int32_t _scratch_size_bytes) {
    return SetField<int32_t>(VT_SCRATCH_SIZE_BYTES, _scratch_size_bytes, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::InstructionBitstream>> *instruction_bitstreams() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::InstructionBitstream>> *>(VT_INSTRUCTION_BITSTREAMS);
  }
  flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::InstructionBitstream>> *mutable_instruction_bitstreams() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::InstructionBitstream>> *>(VT_INSTRUCTION_BITSTREAMS);
  }
  const flatbuffers::Vector<uint8_t> *parameters() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PARAMETERS);
  }
  flatbuffers::Vector<uint8_t> *mutable_parameters() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PARAMETERS);
  }
  const platforms::darwinn::DmaHints *dma_hints() const {
    return GetPointer<const platforms::darwinn::DmaHints *>(VT_DMA_HINTS);
  }
  platforms::darwinn::DmaHints *mutable_dma_hints() {
    return GetPointer<platforms::darwinn::DmaHints *>(VT_DMA_HINTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::Layer>> *input_layers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::Layer>> *>(VT_INPUT_LAYERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::Layer>> *mutable_input_layers() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::Layer>> *>(VT_INPUT_LAYERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::Layer>> *output_layers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::Layer>> *>(VT_OUTPUT_LAYERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::Layer>> *mutable_output_layers() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::Layer>> *>(VT_OUTPUT_LAYERS);
  }
  const flatbuffers::String *chip() const {
    return GetPointer<const flatbuffers::String *>(VT_CHIP);
  }
  flatbuffers::String *mutable_chip() {
    return GetPointer<flatbuffers::String *>(VT_CHIP);
  }
  int32_t estimated_cycles() const {
    return GetField<int32_t>(VT_ESTIMATED_CYCLES, 0);
  }
  bool mutate_estimated_cycles(int32_t _estimated_cycles) {
    return SetField<int32_t>(VT_ESTIMATED_CYCLES, _estimated_cycles, 0);
  }
  int32_t used_narrow_memory_bytes_per_tile() const {
    return GetField<int32_t>(VT_USED_NARROW_MEMORY_BYTES_PER_TILE, 0);
  }
  bool mutate_used_narrow_memory_bytes_per_tile(int32_t _used_narrow_memory_bytes_per_tile) {
    return SetField<int32_t>(VT_USED_NARROW_MEMORY_BYTES_PER_TILE, _used_narrow_memory_bytes_per_tile, 0);
  }
  platforms::darwinn::ExecutableType type() const {
    return static_cast<platforms::darwinn::ExecutableType>(GetField<int16_t>(VT_TYPE, 0));
  }
  bool mutate_type(platforms::darwinn::ExecutableType _type) {
    return SetField<int16_t>(VT_TYPE, static_cast<int16_t>(_type), 0);
  }
  uint64_t parameter_caching_token() const {
    return GetField<uint64_t>(VT_PARAMETER_CACHING_TOKEN, 0);
  }
  bool mutate_parameter_caching_token(uint64_t _parameter_caching_token) {
    return SetField<uint64_t>(VT_PARAMETER_CACHING_TOKEN, _parameter_caching_token, 0);
  }
  bool use_tpu_dram_for_parameters() const {
    return GetField<uint8_t>(VT_USE_TPU_DRAM_FOR_PARAMETERS, 0) != 0;
  }
  bool mutate_use_tpu_dram_for_parameters(bool _use_tpu_dram_for_parameters) {
    return SetField<uint8_t>(VT_USE_TPU_DRAM_FOR_PARAMETERS, static_cast<uint8_t>(_use_tpu_dram_for_parameters), 0);
  }
  int64_t estimated_cycles_64bit() const {
    return GetField<int64_t>(VT_ESTIMATED_CYCLES_64BIT, 0);
  }
  bool mutate_estimated_cycles_64bit(int64_t _estimated_cycles_64bit) {
    return SetField<int64_t>(VT_ESTIMATED_CYCLES_64BIT, _estimated_cycles_64bit, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VERSION, sizeof(int32_t)) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SERIALIZED_MODEL) &&
           verifier.VerifyVector(serialized_model()) &&
           VerifyField<int32_t>(verifier, VT_BATCH_SIZE, sizeof(int32_t)) &&
           VerifyField<int32_t>(verifier, VT_SCRATCH_SIZE_BYTES, sizeof(int32_t)) &&
           VerifyOffset(verifier, VT_INSTRUCTION_BITSTREAMS) &&
           verifier.VerifyVector(instruction_bitstreams()) &&
           verifier.VerifyVectorOfTables(instruction_bitstreams()) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           VerifyOffset(verifier, VT_DMA_HINTS) &&
           verifier.VerifyTable(dma_hints()) &&
           VerifyOffset(verifier, VT_INPUT_LAYERS) &&
           verifier.VerifyVector(input_layers()) &&
           verifier.VerifyVectorOfTables(input_layers()) &&
           VerifyOffset(verifier, VT_OUTPUT_LAYERS) &&
           verifier.VerifyVector(output_layers()) &&
           verifier.VerifyVectorOfTables(output_layers()) &&
           VerifyOffset(verifier, VT_CHIP) &&
           verifier.VerifyString(chip()) &&
           VerifyField<int32_t>(verifier, VT_ESTIMATED_CYCLES, sizeof(int32_t)) &&
           VerifyField<int32_t>(verifier, VT_USED_NARROW_MEMORY_BYTES_PER_TILE, sizeof(int32_t)) &&
           VerifyField<int16_t>(verifier, VT_TYPE, sizeof(int16_t)) &&
           VerifyField<uint64_t>(verifier, VT_PARAMETER_CACHING_TOKEN, sizeof(uint64_t)) &&
           VerifyField<uint8_t>(verifier, VT_USE_TPU_DRAM_FOR_PARAMETERS, sizeof(uint8_t)) &&
           VerifyField<int64_t>(verifier, VT_ESTIMATED_CYCLES_64BIT, sizeof(int64_t)) &&
           verifier.EndTable();
  }
  ExecutableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExecutableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Executable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecutableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExecutableBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(int32_t version) {
    fbb_.AddElement<int32_t>(Executable::VT_VERSION, version, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Executable::VT_NAME, name);
  }
  void add_serialized_model(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> serialized_model) {
    fbb_.AddOffset(Executable::VT_SERIALIZED_MODEL, serialized_model);
  }
  void add_batch_size(int32_t batch_size) {
    fbb_.AddElement<int32_t>(Executable::VT_BATCH_SIZE, batch_size, 0);
  }
  void add_scratch_size_bytes(int32_t scratch_size_bytes) {
    fbb_.AddElement<int32_t>(Executable::VT_SCRATCH_SIZE_BYTES, scratch_size_bytes, 0);
  }
  void add_instruction_bitstreams(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::InstructionBitstream>>> instruction_bitstreams) {
    fbb_.AddOffset(Executable::VT_INSTRUCTION_BITSTREAMS, instruction_bitstreams);
  }
  void add_parameters(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> parameters) {
    fbb_.AddOffset(Executable::VT_PARAMETERS, parameters);
  }
  void add_dma_hints(flatbuffers::Offset<platforms::darwinn::DmaHints> dma_hints) {
    fbb_.AddOffset(Executable::VT_DMA_HINTS, dma_hints);
  }
  void add_input_layers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::Layer>>> input_layers) {
    fbb_.AddOffset(Executable::VT_INPUT_LAYERS, input_layers);
  }
  void add_output_layers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::Layer>>> output_layers) {
    fbb_.AddOffset(Executable::VT_OUTPUT_LAYERS, output_layers);
  }
  void add_chip(flatbuffers::Offset<flatbuffers::String> chip) {
    fbb_.AddOffset(Executable::VT_CHIP, chip);
  }
  void add_estimated_cycles(int32_t estimated_cycles) {
    fbb_.AddElement<int32_t>(Executable::VT_ESTIMATED_CYCLES, estimated_cycles, 0);
  }
  void add_used_narrow_memory_bytes_per_tile(int32_t used_narrow_memory_bytes_per_tile) {
    fbb_.AddElement<int32_t>(Executable::VT_USED_NARROW_MEMORY_BYTES_PER_TILE, used_narrow_memory_bytes_per_tile, 0);
  }
  void add_type(platforms::darwinn::ExecutableType type) {
    fbb_.AddElement<int16_t>(Executable::VT_TYPE, static_cast<int16_t>(type), 0);
  }
  void add_parameter_caching_token(uint64_t parameter_caching_token) {
    fbb_.AddElement<uint64_t>(Executable::VT_PARAMETER_CACHING_TOKEN, parameter_caching_token, 0);
  }
  void add_use_tpu_dram_for_parameters(bool use_tpu_dram_for_parameters) {
    fbb_.AddElement<uint8_t>(Executable::VT_USE_TPU_DRAM_FOR_PARAMETERS, static_cast<uint8_t>(use_tpu_dram_for_parameters), 0);
  }
  void add_estimated_cycles_64bit(int64_t estimated_cycles_64bit) {
    fbb_.AddElement<int64_t>(Executable::VT_ESTIMATED_CYCLES_64BIT, estimated_cycles_64bit, 0);
  }
  explicit ExecutableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExecutableBuilder &operator=(const ExecutableBuilder &);
  flatbuffers::Offset<Executable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Executable>(end);
    return o;
  }
};

inline flatbuffers::Offset<Executable> CreateExecutable(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t version = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> serialized_model = 0,
    int32_t batch_size = 0,
    int32_t scratch_size_bytes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::InstructionBitstream>>> instruction_bitstreams = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> parameters = 0,
    flatbuffers::Offset<platforms::darwinn::DmaHints> dma_hints = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::Layer>>> input_layers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::Layer>>> output_layers = 0,
    flatbuffers::Offset<flatbuffers::String> chip = 0,
    int32_t estimated_cycles = 0,
    int32_t used_narrow_memory_bytes_per_tile = 0,
    platforms::darwinn::ExecutableType type = platforms::darwinn::ExecutableType_STAND_ALONE,
    uint64_t parameter_caching_token = 0,
    bool use_tpu_dram_for_parameters = false,
    int64_t estimated_cycles_64bit = 0) {
  ExecutableBuilder builder_(_fbb);
  builder_.add_estimated_cycles_64bit(estimated_cycles_64bit);
  builder_.add_parameter_caching_token(parameter_caching_token);
  builder_.add_used_narrow_memory_bytes_per_tile(used_narrow_memory_bytes_per_tile);
  builder_.add_estimated_cycles(estimated_cycles);
  builder_.add_chip(chip);
  builder_.add_output_layers(output_layers);
  builder_.add_input_layers(input_layers);
  builder_.add_dma_hints(dma_hints);
  builder_.add_parameters(parameters);
  builder_.add_instruction_bitstreams(instruction_bitstreams);
  builder_.add_scratch_size_bytes(scratch_size_bytes);
  builder_.add_batch_size(batch_size);
  builder_.add_serialized_model(serialized_model);
  builder_.add_name(name);
  builder_.add_version(version);
  builder_.add_type(type);
  builder_.add_use_tpu_dram_for_parameters(use_tpu_dram_for_parameters);
  return builder_.Finish();
}

inline flatbuffers::Offset<Executable> CreateExecutableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t version = 0,
    const char *name = nullptr,
    const std::vector<uint8_t> *serialized_model = nullptr,
    int32_t batch_size = 0,
    int32_t scratch_size_bytes = 0,
    const std::vector<flatbuffers::Offset<platforms::darwinn::InstructionBitstream>> *instruction_bitstreams = nullptr,
    const std::vector<uint8_t> *parameters = nullptr,
    flatbuffers::Offset<platforms::darwinn::DmaHints> dma_hints = 0,
    const std::vector<flatbuffers::Offset<platforms::darwinn::Layer>> *input_layers = nullptr,
    const std::vector<flatbuffers::Offset<platforms::darwinn::Layer>> *output_layers = nullptr,
    const char *chip = nullptr,
    int32_t estimated_cycles = 0,
    int32_t used_narrow_memory_bytes_per_tile = 0,
    platforms::darwinn::ExecutableType type = platforms::darwinn::ExecutableType_STAND_ALONE,
    uint64_t parameter_caching_token = 0,
    bool use_tpu_dram_for_parameters = false,
    int64_t estimated_cycles_64bit = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto serialized_model__ = serialized_model ? _fbb.CreateVector<uint8_t>(*serialized_model) : 0;
  auto instruction_bitstreams__ = instruction_bitstreams ? _fbb.CreateVector<flatbuffers::Offset<platforms::darwinn::InstructionBitstream>>(*instruction_bitstreams) : 0;
  auto parameters__ = parameters ? _fbb.CreateVector<uint8_t>(*parameters) : 0;
  auto input_layers__ = input_layers ? _fbb.CreateVector<flatbuffers::Offset<platforms::darwinn::Layer>>(*input_layers) : 0;
  auto output_layers__ = output_layers ? _fbb.CreateVector<flatbuffers::Offset<platforms::darwinn::Layer>>(*output_layers) : 0;
  auto chip__ = chip ? _fbb.CreateString(chip) : 0;
  return platforms::darwinn::CreateExecutable(
      _fbb,
      version,
      name__,
      serialized_model__,
      batch_size,
      scratch_size_bytes,
      instruction_bitstreams__,
      parameters__,
      dma_hints,
      input_layers__,
      output_layers__,
      chip__,
      estimated_cycles,
      used_narrow_memory_bytes_per_tile,
      type,
      parameter_caching_token,
      use_tpu_dram_for_parameters,
      estimated_cycles_64bit);
}

flatbuffers::Offset<Executable> CreateExecutable(flatbuffers::FlatBufferBuilder &_fbb, const ExecutableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MultiExecutableT : public flatbuffers::NativeTable {
  typedef MultiExecutable TableType;
  std::vector<std::string> serialized_executables;
  MultiExecutableT() {
  }
};

struct MultiExecutable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MultiExecutableT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERIALIZED_EXECUTABLES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *serialized_executables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_SERIALIZED_EXECUTABLES);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_serialized_executables() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_SERIALIZED_EXECUTABLES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SERIALIZED_EXECUTABLES) &&
           verifier.VerifyVector(serialized_executables()) &&
           verifier.VerifyVectorOfStrings(serialized_executables()) &&
           verifier.EndTable();
  }
  MultiExecutableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MultiExecutableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MultiExecutable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MultiExecutableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MultiExecutableBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_serialized_executables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> serialized_executables) {
    fbb_.AddOffset(MultiExecutable::VT_SERIALIZED_EXECUTABLES, serialized_executables);
  }
  explicit MultiExecutableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MultiExecutableBuilder &operator=(const MultiExecutableBuilder &);
  flatbuffers::Offset<MultiExecutable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MultiExecutable>(end);
    return o;
  }
};

inline flatbuffers::Offset<MultiExecutable> CreateMultiExecutable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> serialized_executables = 0) {
  MultiExecutableBuilder builder_(_fbb);
  builder_.add_serialized_executables(serialized_executables);
  return builder_.Finish();
}

inline flatbuffers::Offset<MultiExecutable> CreateMultiExecutableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *serialized_executables = nullptr) {
  auto serialized_executables__ = serialized_executables ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*serialized_executables) : 0;
  return platforms::darwinn::CreateMultiExecutable(
      _fbb,
      serialized_executables__);
}

flatbuffers::Offset<MultiExecutable> CreateMultiExecutable(flatbuffers::FlatBufferBuilder &_fbb, const MultiExecutableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SerializedPackageT : public flatbuffers::NativeTable {
  typedef SerializedPackage TableType;
  std::vector<uint8_t> serialized_package;
  SerializedPackageT() {
  }
};

struct SerializedPackage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SerializedPackageT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERIALIZED_PACKAGE = 4
  };
  const flatbuffers::Vector<uint8_t> *serialized_package() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SERIALIZED_PACKAGE);
  }
  flatbuffers::Vector<uint8_t> *mutable_serialized_package() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_SERIALIZED_PACKAGE);
  }
  const platforms::darwinn::Package *serialized_package_nested_root() const {
    return flatbuffers::GetRoot<platforms::darwinn::Package>(serialized_package()->Data());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SERIALIZED_PACKAGE) &&
           verifier.VerifyVector(serialized_package()) &&
           verifier.EndTable();
  }
  SerializedPackageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SerializedPackageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SerializedPackage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SerializedPackageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SerializedPackageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_serialized_package(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> serialized_package) {
    fbb_.AddOffset(SerializedPackage::VT_SERIALIZED_PACKAGE, serialized_package);
  }
  explicit SerializedPackageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SerializedPackageBuilder &operator=(const SerializedPackageBuilder &);
  flatbuffers::Offset<SerializedPackage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SerializedPackage>(end);
    return o;
  }
};

inline flatbuffers::Offset<SerializedPackage> CreateSerializedPackage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> serialized_package = 0) {
  SerializedPackageBuilder builder_(_fbb);
  builder_.add_serialized_package(serialized_package);
  return builder_.Finish();
}

inline flatbuffers::Offset<SerializedPackage> CreateSerializedPackageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *serialized_package = nullptr) {
  auto serialized_package__ = serialized_package ? _fbb.CreateVector<uint8_t>(*serialized_package) : 0;
  return platforms::darwinn::CreateSerializedPackage(
      _fbb,
      serialized_package__);
}

flatbuffers::Offset<SerializedPackage> CreateSerializedPackage(flatbuffers::FlatBufferBuilder &_fbb, const SerializedPackageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PackageT : public flatbuffers::NativeTable {
  typedef Package TableType;
  int32_t min_runtime_version;
  std::vector<uint8_t> serialized_multi_executable;
  std::vector<uint8_t> signature;
  int32_t keypair_version;
  std::string compiler_version;
  int32_t virtual_chip_id;
  std::vector<std::unique_ptr<platforms::darwinn::SerializedPackageT>> multi_chip_package;
  std::string model_identifier;
  PackageT()
      : min_runtime_version(0),
        keypair_version(0),
        virtual_chip_id(0) {
  }
};

struct Package FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PackageT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_RUNTIME_VERSION = 4,
    VT_SERIALIZED_MULTI_EXECUTABLE = 6,
    VT_SIGNATURE = 8,
    VT_KEYPAIR_VERSION = 10,
    VT_COMPILER_VERSION = 12,
    VT_VIRTUAL_CHIP_ID = 14,
    VT_MULTI_CHIP_PACKAGE = 16,
    VT_MODEL_IDENTIFIER = 18
  };
  int32_t min_runtime_version() const {
    return GetField<int32_t>(VT_MIN_RUNTIME_VERSION, 0);
  }
  bool mutate_min_runtime_version(int32_t _min_runtime_version) {
    return SetField<int32_t>(VT_MIN_RUNTIME_VERSION, _min_runtime_version, 0);
  }
  const flatbuffers::Vector<uint8_t> *serialized_multi_executable() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SERIALIZED_MULTI_EXECUTABLE);
  }
  flatbuffers::Vector<uint8_t> *mutable_serialized_multi_executable() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_SERIALIZED_MULTI_EXECUTABLE);
  }
  const flatbuffers::Vector<uint8_t> *signature() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIGNATURE);
  }
  flatbuffers::Vector<uint8_t> *mutable_signature() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_SIGNATURE);
  }
  int32_t keypair_version() const {
    return GetField<int32_t>(VT_KEYPAIR_VERSION, 0);
  }
  bool mutate_keypair_version(int32_t _keypair_version) {
    return SetField<int32_t>(VT_KEYPAIR_VERSION, _keypair_version, 0);
  }
  const flatbuffers::String *compiler_version() const {
    return GetPointer<const flatbuffers::String *>(VT_COMPILER_VERSION);
  }
  flatbuffers::String *mutable_compiler_version() {
    return GetPointer<flatbuffers::String *>(VT_COMPILER_VERSION);
  }
  int32_t virtual_chip_id() const {
    return GetField<int32_t>(VT_VIRTUAL_CHIP_ID, 0);
  }
  bool mutate_virtual_chip_id(int32_t _virtual_chip_id) {
    return SetField<int32_t>(VT_VIRTUAL_CHIP_ID, _virtual_chip_id, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::SerializedPackage>> *multi_chip_package() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::SerializedPackage>> *>(VT_MULTI_CHIP_PACKAGE);
  }
  flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::SerializedPackage>> *mutable_multi_chip_package() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::SerializedPackage>> *>(VT_MULTI_CHIP_PACKAGE);
  }
  const flatbuffers::String *model_identifier() const {
    return GetPointer<const flatbuffers::String *>(VT_MODEL_IDENTIFIER);
  }
  flatbuffers::String *mutable_model_identifier() {
    return GetPointer<flatbuffers::String *>(VT_MODEL_IDENTIFIER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MIN_RUNTIME_VERSION, sizeof(int32_t)) &&
           VerifyOffset(verifier, VT_SERIALIZED_MULTI_EXECUTABLE) &&
           verifier.VerifyVector(serialized_multi_executable()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyVector(signature()) &&
           VerifyField<int32_t>(verifier, VT_KEYPAIR_VERSION, sizeof(int32_t)) &&
           VerifyOffset(verifier, VT_COMPILER_VERSION) &&
           verifier.VerifyString(compiler_version()) &&
           VerifyField<int32_t>(verifier, VT_VIRTUAL_CHIP_ID, sizeof(int32_t)) &&
           VerifyOffset(verifier, VT_MULTI_CHIP_PACKAGE) &&
           verifier.VerifyVector(multi_chip_package()) &&
           verifier.VerifyVectorOfTables(multi_chip_package()) &&
           VerifyOffset(verifier, VT_MODEL_IDENTIFIER) &&
           verifier.VerifyString(model_identifier()) &&
           verifier.EndTable();
  }
  PackageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PackageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Package> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PackageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PackageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min_runtime_version(int32_t min_runtime_version) {
    fbb_.AddElement<int32_t>(Package::VT_MIN_RUNTIME_VERSION, min_runtime_version, 0);
  }
  void add_serialized_multi_executable(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> serialized_multi_executable) {
    fbb_.AddOffset(Package::VT_SERIALIZED_MULTI_EXECUTABLE, serialized_multi_executable);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature) {
    fbb_.AddOffset(Package::VT_SIGNATURE, signature);
  }
  void add_keypair_version(int32_t keypair_version) {
    fbb_.AddElement<int32_t>(Package::VT_KEYPAIR_VERSION, keypair_version, 0);
  }
  void add_compiler_version(flatbuffers::Offset<flatbuffers::String> compiler_version) {
    fbb_.AddOffset(Package::VT_COMPILER_VERSION, compiler_version);
  }
  void add_virtual_chip_id(int32_t virtual_chip_id) {
    fbb_.AddElement<int32_t>(Package::VT_VIRTUAL_CHIP_ID, virtual_chip_id, 0);
  }
  void add_multi_chip_package(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::SerializedPackage>>> multi_chip_package) {
    fbb_.AddOffset(Package::VT_MULTI_CHIP_PACKAGE, multi_chip_package);
  }
  void add_model_identifier(flatbuffers::Offset<flatbuffers::String> model_identifier) {
    fbb_.AddOffset(Package::VT_MODEL_IDENTIFIER, model_identifier);
  }
  explicit PackageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PackageBuilder &operator=(const PackageBuilder &);
  flatbuffers::Offset<Package> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Package>(end);
    return o;
  }
};

inline flatbuffers::Offset<Package> CreatePackage(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t min_runtime_version = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> serialized_multi_executable = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature = 0,
    int32_t keypair_version = 0,
    flatbuffers::Offset<flatbuffers::String> compiler_version = 0,
    int32_t virtual_chip_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<platforms::darwinn::SerializedPackage>>> multi_chip_package = 0,
    flatbuffers::Offset<flatbuffers::String> model_identifier = 0) {
  PackageBuilder builder_(_fbb);
  builder_.add_model_identifier(model_identifier);
  builder_.add_multi_chip_package(multi_chip_package);
  builder_.add_virtual_chip_id(virtual_chip_id);
  builder_.add_compiler_version(compiler_version);
  builder_.add_keypair_version(keypair_version);
  builder_.add_signature(signature);
  builder_.add_serialized_multi_executable(serialized_multi_executable);
  builder_.add_min_runtime_version(min_runtime_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<Package> CreatePackageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t min_runtime_version = 0,
    const std::vector<uint8_t> *serialized_multi_executable = nullptr,
    const std::vector<uint8_t> *signature = nullptr,
    int32_t keypair_version = 0,
    const char *compiler_version = nullptr,
    int32_t virtual_chip_id = 0,
    const std::vector<flatbuffers::Offset<platforms::darwinn::SerializedPackage>> *multi_chip_package = nullptr,
    const char *model_identifier = nullptr) {
  auto serialized_multi_executable__ = serialized_multi_executable ? _fbb.CreateVector<uint8_t>(*serialized_multi_executable) : 0;
  auto signature__ = signature ? _fbb.CreateVector<uint8_t>(*signature) : 0;
  auto compiler_version__ = compiler_version ? _fbb.CreateString(compiler_version) : 0;
  auto multi_chip_package__ = multi_chip_package ? _fbb.CreateVector<flatbuffers::Offset<platforms::darwinn::SerializedPackage>>(*multi_chip_package) : 0;
  auto model_identifier__ = model_identifier ? _fbb.CreateString(model_identifier) : 0;
  return platforms::darwinn::CreatePackage(
      _fbb,
      min_runtime_version,
      serialized_multi_executable__,
      signature__,
      keypair_version,
      compiler_version__,
      virtual_chip_id,
      multi_chip_package__,
      model_identifier__);
}

flatbuffers::Offset<Package> CreatePackage(flatbuffers::FlatBufferBuilder &_fbb, const PackageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline MetaT *Meta::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MetaT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Meta::UnPackTo(MetaT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = desc(); _o->desc = _e; }
  { auto _e = batch(); _o->batch = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = position(); _o->position = _e; }
}

inline flatbuffers::Offset<Meta> Meta::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetaT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMeta(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Meta> CreateMeta(flatbuffers::FlatBufferBuilder &_fbb, const MetaT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MetaT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _desc = _o->desc;
  auto _batch = _o->batch;
  auto _name = _o->name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->name);
  auto _position = _o->position;
  return platforms::darwinn::CreateMeta(
      _fbb,
      _desc,
      _batch,
      _name,
      _position);
}

inline FieldOffsetT *FieldOffset::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FieldOffsetT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FieldOffset::UnPackTo(FieldOffsetT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = meta(); if (_e) _o->meta = std::unique_ptr<platforms::darwinn::MetaT>(_e->UnPack(_resolver)); }
  { auto _e = offset_bit(); _o->offset_bit = _e; }
}

inline flatbuffers::Offset<FieldOffset> FieldOffset::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FieldOffsetT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFieldOffset(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FieldOffset> CreateFieldOffset(flatbuffers::FlatBufferBuilder &_fbb, const FieldOffsetT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FieldOffsetT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _meta = _o->meta ? CreateMeta(_fbb, _o->meta.get(), _rehasher) : 0;
  auto _offset_bit = _o->offset_bit;
  return platforms::darwinn::CreateFieldOffset(
      _fbb,
      _meta,
      _offset_bit);
}

inline InstructionBitstreamT *InstructionBitstream::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new InstructionBitstreamT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void InstructionBitstream::UnPackTo(InstructionBitstreamT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = bitstream(); if (_e) { _o->bitstream.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->bitstream.begin()); } }
  { auto _e = field_offsets(); if (_e) { _o->field_offsets.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->field_offsets[_i] = std::unique_ptr<platforms::darwinn::FieldOffsetT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<InstructionBitstream> InstructionBitstream::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InstructionBitstreamT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInstructionBitstream(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InstructionBitstream> CreateInstructionBitstream(flatbuffers::FlatBufferBuilder &_fbb, const InstructionBitstreamT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InstructionBitstreamT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _bitstream = _fbb.CreateVector(_o->bitstream);
  auto _field_offsets = _fbb.CreateVector<flatbuffers::Offset<platforms::darwinn::FieldOffset>> (_o->field_offsets.size(), [](size_t i, _VectorArgs *__va) { return CreateFieldOffset(*__va->__fbb, __va->__o->field_offsets[i].get(), __va->__rehasher); }, &_va );
  return platforms::darwinn::CreateInstructionBitstream(
      _fbb,
      _bitstream,
      _field_offsets);
}

inline DmaDescriptorHintT *DmaDescriptorHint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DmaDescriptorHintT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DmaDescriptorHint::UnPackTo(DmaDescriptorHintT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = meta(); if (_e) _o->meta = std::unique_ptr<platforms::darwinn::MetaT>(_e->UnPack(_resolver)); }
  { auto _e = offset_in_bytes(); _o->offset_in_bytes = _e; }
  { auto _e = size_in_bytes(); _o->size_in_bytes = _e; }
}

inline flatbuffers::Offset<DmaDescriptorHint> DmaDescriptorHint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DmaDescriptorHintT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDmaDescriptorHint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DmaDescriptorHint> CreateDmaDescriptorHint(flatbuffers::FlatBufferBuilder &_fbb, const DmaDescriptorHintT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DmaDescriptorHintT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _meta = _o->meta ? CreateMeta(_fbb, _o->meta.get(), _rehasher) : 0;
  auto _offset_in_bytes = _o->offset_in_bytes;
  auto _size_in_bytes = _o->size_in_bytes;
  return platforms::darwinn::CreateDmaDescriptorHint(
      _fbb,
      _meta,
      _offset_in_bytes,
      _size_in_bytes);
}

inline InterruptHintT *InterruptHint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new InterruptHintT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void InterruptHint::UnPackTo(InterruptHintT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
}

inline flatbuffers::Offset<InterruptHint> InterruptHint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InterruptHintT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInterruptHint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InterruptHint> CreateInterruptHint(flatbuffers::FlatBufferBuilder &_fbb, const InterruptHintT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InterruptHintT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  return platforms::darwinn::CreateInterruptHint(
      _fbb,
      _type);
}

inline InstructionHintT *InstructionHint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new InstructionHintT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void InstructionHint::UnPackTo(InstructionHintT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = instruction_chunk_index(); _o->instruction_chunk_index = _e; }
}

inline flatbuffers::Offset<InstructionHint> InstructionHint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InstructionHintT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInstructionHint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InstructionHint> CreateInstructionHint(flatbuffers::FlatBufferBuilder &_fbb, const InstructionHintT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InstructionHintT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _instruction_chunk_index = _o->instruction_chunk_index;
  return platforms::darwinn::CreateInstructionHint(
      _fbb,
      _instruction_chunk_index);
}

inline FenceHintT *FenceHint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FenceHintT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FenceHint::UnPackTo(FenceHintT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<FenceHint> FenceHint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FenceHintT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFenceHint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FenceHint> CreateFenceHint(flatbuffers::FlatBufferBuilder &_fbb, const FenceHintT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FenceHintT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return platforms::darwinn::CreateFenceHint(
      _fbb);
}

inline DmaHintT *DmaHint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DmaHintT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DmaHint::UnPackTo(DmaHintT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = any_hint_type(); _o->any_hint.type = _e; }
  { auto _e = any_hint(); if (_e) _o->any_hint.value = platforms::darwinn::AnyHintUnion::UnPack(_e, any_hint_type(), _resolver); }
  { auto _e = direction(); _o->direction = _e; }
}

inline flatbuffers::Offset<DmaHint> DmaHint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DmaHintT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDmaHint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DmaHint> CreateDmaHint(flatbuffers::FlatBufferBuilder &_fbb, const DmaHintT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DmaHintT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _any_hint_type = _o->any_hint.type;
  auto _any_hint = _o->any_hint.Pack(_fbb);
  auto _direction = _o->direction;
  return platforms::darwinn::CreateDmaHint(
      _fbb,
      _any_hint_type,
      _any_hint,
      _direction);
}

inline DmaHintsT *DmaHints::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DmaHintsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DmaHints::UnPackTo(DmaHintsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hints(); if (_e) { _o->hints.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->hints[_i] = std::unique_ptr<platforms::darwinn::DmaHintT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = fully_deterministic(); _o->fully_deterministic = _e; }
}

inline flatbuffers::Offset<DmaHints> DmaHints::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DmaHintsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDmaHints(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DmaHints> CreateDmaHints(flatbuffers::FlatBufferBuilder &_fbb, const DmaHintsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DmaHintsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _hints = _fbb.CreateVector<flatbuffers::Offset<platforms::darwinn::DmaHint>> (_o->hints.size(), [](size_t i, _VectorArgs *__va) { return CreateDmaHint(*__va->__fbb, __va->__o->hints[i].get(), __va->__rehasher); }, &_va );
  auto _fully_deterministic = _o->fully_deterministic;
  return platforms::darwinn::CreateDmaHints(
      _fbb,
      _hints,
      _fully_deterministic);
}

inline OutputLayoutT *OutputLayout::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new OutputLayoutT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void OutputLayout::UnPackTo(OutputLayoutT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = y_coordinate_to_linear_tile_id_map(); if (_e) { _o->y_coordinate_to_linear_tile_id_map.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->y_coordinate_to_linear_tile_id_map[_i] = _e->Get(_i); } } }
  { auto _e = x_coordinate_to_linear_tile_id_map(); if (_e) { _o->x_coordinate_to_linear_tile_id_map.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->x_coordinate_to_linear_tile_id_map[_i] = _e->Get(_i); } } }
  { auto _e = linearized_tile_byte_offset(); if (_e) { _o->linearized_tile_byte_offset.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->linearized_tile_byte_offset[_i] = _e->Get(_i); } } }
  { auto _e = x_coordinate_to_local_byte_offset(); if (_e) { _o->x_coordinate_to_local_byte_offset.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->x_coordinate_to_local_byte_offset[_i] = _e->Get(_i); } } }
  { auto _e = y_coordinate_to_local_y_offset(); if (_e) { _o->y_coordinate_to_local_y_offset.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->y_coordinate_to_local_y_offset[_i] = _e->Get(_i); } } }
  { auto _e = x_coordinate_to_local_y_row_size(); if (_e) { _o->x_coordinate_to_local_y_row_size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->x_coordinate_to_local_y_row_size[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<OutputLayout> OutputLayout::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OutputLayoutT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOutputLayout(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OutputLayout> CreateOutputLayout(flatbuffers::FlatBufferBuilder &_fbb, const OutputLayoutT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OutputLayoutT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _y_coordinate_to_linear_tile_id_map = _fbb.CreateVector(_o->y_coordinate_to_linear_tile_id_map);
  auto _x_coordinate_to_linear_tile_id_map = _fbb.CreateVector(_o->x_coordinate_to_linear_tile_id_map);
  auto _linearized_tile_byte_offset = _fbb.CreateVector(_o->linearized_tile_byte_offset);
  auto _x_coordinate_to_local_byte_offset = _fbb.CreateVector(_o->x_coordinate_to_local_byte_offset);
  auto _y_coordinate_to_local_y_offset = _fbb.CreateVector(_o->y_coordinate_to_local_y_offset);
  auto _x_coordinate_to_local_y_row_size = _fbb.CreateVector(_o->x_coordinate_to_local_y_row_size);
  return platforms::darwinn::CreateOutputLayout(
      _fbb,
      _y_coordinate_to_linear_tile_id_map,
      _x_coordinate_to_linear_tile_id_map,
      _linearized_tile_byte_offset,
      _x_coordinate_to_local_byte_offset,
      _y_coordinate_to_local_y_offset,
      _x_coordinate_to_local_y_row_size);
}

inline TensorShapeT *TensorShape::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TensorShapeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TensorShape::UnPackTo(TensorShapeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dimension(); if (_e) { _o->dimension.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dimension[_i] = *_e->Get(_i); } } }
}

inline flatbuffers::Offset<TensorShape> TensorShape::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorShapeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorShape(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorShape> CreateTensorShape(flatbuffers::FlatBufferBuilder &_fbb, const TensorShapeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorShapeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dimension = _fbb.CreateVectorOfStructs(_o->dimension);
  return platforms::darwinn::CreateTensorShape(
      _fbb,
      _dimension);
}

inline TensorLayoutT *TensorLayout::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TensorLayoutT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TensorLayout::UnPackTo(TensorLayoutT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = shape(); if (_e) _o->shape = std::unique_ptr<platforms::darwinn::TensorShapeT>(_e->UnPack(_resolver)); }
  { auto _e = stride(); if (_e) { _o->stride.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stride[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<TensorLayout> TensorLayout::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorLayoutT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorLayout(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorLayout> CreateTensorLayout(flatbuffers::FlatBufferBuilder &_fbb, const TensorLayoutT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorLayoutT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _shape = _o->shape ? CreateTensorShape(_fbb, _o->shape.get(), _rehasher) : 0;
  auto _stride = _fbb.CreateVector(_o->stride);
  return platforms::darwinn::CreateTensorLayout(
      _fbb,
      _shape,
      _stride);
}

inline OutputShapeInfoT *OutputShapeInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new OutputShapeInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void OutputShapeInfo::UnPackTo(OutputShapeInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slice_layout(); if (_e) { _o->slice_layout.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slice_layout[_i] = std::unique_ptr<platforms::darwinn::TensorLayoutT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = slice_offset(); if (_e) { _o->slice_offset.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slice_offset[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<OutputShapeInfo> OutputShapeInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OutputShapeInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOutputShapeInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OutputShapeInfo> CreateOutputShapeInfo(flatbuffers::FlatBufferBuilder &_fbb, const OutputShapeInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OutputShapeInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slice_layout = _fbb.CreateVector<flatbuffers::Offset<platforms::darwinn::TensorLayout>> (_o->slice_layout.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorLayout(*__va->__fbb, __va->__o->slice_layout[i].get(), __va->__rehasher); }, &_va );
  auto _slice_offset = _fbb.CreateVector(_o->slice_offset);
  return platforms::darwinn::CreateOutputShapeInfo(
      _fbb,
      _slice_layout,
      _slice_offset);
}

inline NumericsConstantsT *NumericsConstants::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NumericsConstantsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NumericsConstants::UnPackTo(NumericsConstantsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = zero_point(); _o->zero_point = _e; }
  { auto _e = dequantization_factor(); _o->dequantization_factor = _e; }
}

inline flatbuffers::Offset<NumericsConstants> NumericsConstants::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NumericsConstantsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNumericsConstants(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NumericsConstants> CreateNumericsConstants(flatbuffers::FlatBufferBuilder &_fbb, const NumericsConstantsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NumericsConstantsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _zero_point = _o->zero_point;
  auto _dequantization_factor = _o->dequantization_factor;
  return platforms::darwinn::CreateNumericsConstants(
      _fbb,
      _zero_point,
      _dequantization_factor);
}

inline OutputLayerT *OutputLayer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new OutputLayerT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void OutputLayer::UnPackTo(OutputLayerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = layout(); if (_e) _o->layout = std::unique_ptr<platforms::darwinn::OutputLayoutT>(_e->UnPack(_resolver)); }
  { auto _e = data_type(); _o->data_type = _e; }
  { auto _e = shape_info(); if (_e) _o->shape_info = std::unique_ptr<platforms::darwinn::OutputShapeInfoT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<OutputLayer> OutputLayer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OutputLayerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOutputLayer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OutputLayer> CreateOutputLayer(flatbuffers::FlatBufferBuilder &_fbb, const OutputLayerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OutputLayerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _layout = _o->layout ? CreateOutputLayout(_fbb, _o->layout.get(), _rehasher) : 0;
  auto _data_type = _o->data_type;
  auto _shape_info = _o->shape_info ? CreateOutputShapeInfo(_fbb, _o->shape_info.get(), _rehasher) : 0;
  return platforms::darwinn::CreateOutputLayer(
      _fbb,
      _layout,
      _data_type,
      _shape_info);
}

inline InputLayerT *InputLayer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new InputLayerT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void InputLayer::UnPackTo(InputLayerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<InputLayer> InputLayer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputLayerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInputLayer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InputLayer> CreateInputLayer(flatbuffers::FlatBufferBuilder &_fbb, const InputLayerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InputLayerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return platforms::darwinn::CreateInputLayer(
      _fbb);
}

inline LayerT *Layer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LayerT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Layer::UnPackTo(LayerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = size_bytes(); _o->size_bytes = _e; }
  { auto _e = y_dim(); _o->y_dim = _e; }
  { auto _e = x_dim(); _o->x_dim = _e; }
  { auto _e = z_dim(); _o->z_dim = _e; }
  { auto _e = numerics(); if (_e) _o->numerics = std::unique_ptr<platforms::darwinn::NumericsConstantsT>(_e->UnPack(_resolver)); }
  { auto _e = data_type(); _o->data_type = _e; }
  { auto _e = any_layer_type(); _o->any_layer.type = _e; }
  { auto _e = any_layer(); if (_e) _o->any_layer.value = platforms::darwinn::AnyLayerUnion::UnPack(_e, any_layer_type(), _resolver); }
  { auto _e = execution_count_per_inference(); _o->execution_count_per_inference = _e; }
  { auto _e = cache_on_dram(); _o->cache_on_dram = _e; }
  { auto _e = shape(); if (_e) _o->shape = std::unique_ptr<platforms::darwinn::TensorShapeT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<Layer> Layer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LayerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLayer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Layer> CreateLayer(flatbuffers::FlatBufferBuilder &_fbb, const LayerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LayerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->name);
  auto _size_bytes = _o->size_bytes;
  auto _y_dim = _o->y_dim;
  auto _x_dim = _o->x_dim;
  auto _z_dim = _o->z_dim;
  auto _numerics = _o->numerics ? CreateNumericsConstants(_fbb, _o->numerics.get(), _rehasher) : 0;
  auto _data_type = _o->data_type;
  auto _any_layer_type = _o->any_layer.type;
  auto _any_layer = _o->any_layer.Pack(_fbb);
  auto _execution_count_per_inference = _o->execution_count_per_inference;
  auto _cache_on_dram = _o->cache_on_dram;
  auto _shape = _o->shape ? CreateTensorShape(_fbb, _o->shape.get(), _rehasher) : 0;
  return platforms::darwinn::CreateLayer(
      _fbb,
      _name,
      _size_bytes,
      _y_dim,
      _x_dim,
      _z_dim,
      _numerics,
      _data_type,
      _any_layer_type,
      _any_layer,
      _execution_count_per_inference,
      _cache_on_dram,
      _shape);
}

inline ExecutableT *Executable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ExecutableT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Executable::UnPackTo(ExecutableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = version(); _o->version = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = serialized_model(); if (_e) { _o->serialized_model.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->serialized_model.begin()); } }
  { auto _e = batch_size(); _o->batch_size = _e; }
  { auto _e = scratch_size_bytes(); _o->scratch_size_bytes = _e; }
  { auto _e = instruction_bitstreams(); if (_e) { _o->instruction_bitstreams.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->instruction_bitstreams[_i] = std::unique_ptr<platforms::darwinn::InstructionBitstreamT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = parameters(); if (_e) { _o->parameters.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->parameters.begin()); } }
  { auto _e = dma_hints(); if (_e) _o->dma_hints = std::unique_ptr<platforms::darwinn::DmaHintsT>(_e->UnPack(_resolver)); }
  { auto _e = input_layers(); if (_e) { _o->input_layers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->input_layers[_i] = std::unique_ptr<platforms::darwinn::LayerT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = output_layers(); if (_e) { _o->output_layers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->output_layers[_i] = std::unique_ptr<platforms::darwinn::LayerT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = chip(); if (_e) _o->chip = _e->str(); }
  { auto _e = estimated_cycles(); _o->estimated_cycles = _e; }
  { auto _e = used_narrow_memory_bytes_per_tile(); _o->used_narrow_memory_bytes_per_tile = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = parameter_caching_token(); _o->parameter_caching_token = _e; }
  { auto _e = use_tpu_dram_for_parameters(); _o->use_tpu_dram_for_parameters = _e; }
  { auto _e = estimated_cycles_64bit(); _o->estimated_cycles_64bit = _e; }
}

inline flatbuffers::Offset<Executable> Executable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecutableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExecutable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Executable> CreateExecutable(flatbuffers::FlatBufferBuilder &_fbb, const ExecutableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExecutableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _version = _o->version;
  auto _name = _o->name.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->name);
  auto _serialized_model = _fbb.CreateVector(_o->serialized_model);
  auto _batch_size = _o->batch_size;
  auto _scratch_size_bytes = _o->scratch_size_bytes;
  auto _instruction_bitstreams = _fbb.CreateVector<flatbuffers::Offset<platforms::darwinn::InstructionBitstream>> (_o->instruction_bitstreams.size(), [](size_t i, _VectorArgs *__va) { return CreateInstructionBitstream(*__va->__fbb, __va->__o->instruction_bitstreams[i].get(), __va->__rehasher); }, &_va );
  auto _parameters = _fbb.CreateVector(_o->parameters);
  auto _dma_hints = _o->dma_hints ? CreateDmaHints(_fbb, _o->dma_hints.get(), _rehasher) : 0;
  auto _input_layers = _fbb.CreateVector<flatbuffers::Offset<platforms::darwinn::Layer>> (_o->input_layers.size(), [](size_t i, _VectorArgs *__va) { return CreateLayer(*__va->__fbb, __va->__o->input_layers[i].get(), __va->__rehasher); }, &_va );
  auto _output_layers = _fbb.CreateVector<flatbuffers::Offset<platforms::darwinn::Layer>> (_o->output_layers.size(), [](size_t i, _VectorArgs *__va) { return CreateLayer(*__va->__fbb, __va->__o->output_layers[i].get(), __va->__rehasher); }, &_va );
  auto _chip = _o->chip.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->chip);
  auto _estimated_cycles = _o->estimated_cycles;
  auto _used_narrow_memory_bytes_per_tile = _o->used_narrow_memory_bytes_per_tile;
  auto _type = _o->type;
  auto _parameter_caching_token = _o->parameter_caching_token;
  auto _use_tpu_dram_for_parameters = _o->use_tpu_dram_for_parameters;
  auto _estimated_cycles_64bit = _o->estimated_cycles_64bit;
  return platforms::darwinn::CreateExecutable(
      _fbb,
      _version,
      _name,
      _serialized_model,
      _batch_size,
      _scratch_size_bytes,
      _instruction_bitstreams,
      _parameters,
      _dma_hints,
      _input_layers,
      _output_layers,
      _chip,
      _estimated_cycles,
      _used_narrow_memory_bytes_per_tile,
      _type,
      _parameter_caching_token,
      _use_tpu_dram_for_parameters,
      _estimated_cycles_64bit);
}

inline MultiExecutableT *MultiExecutable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MultiExecutableT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MultiExecutable::UnPackTo(MultiExecutableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = serialized_executables(); if (_e) { _o->serialized_executables.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->serialized_executables[_i] = _e->Get(_i)->str(); } } }
}

inline flatbuffers::Offset<MultiExecutable> MultiExecutable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MultiExecutableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMultiExecutable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MultiExecutable> CreateMultiExecutable(flatbuffers::FlatBufferBuilder &_fbb, const MultiExecutableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MultiExecutableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _serialized_executables = _fbb.CreateVectorOfStrings(_o->serialized_executables);
  return platforms::darwinn::CreateMultiExecutable(
      _fbb,
      _serialized_executables);
}

inline SerializedPackageT *SerializedPackage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SerializedPackageT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SerializedPackage::UnPackTo(SerializedPackageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = serialized_package(); if (_e) { _o->serialized_package.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->serialized_package.begin()); } }
}

inline flatbuffers::Offset<SerializedPackage> SerializedPackage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SerializedPackageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSerializedPackage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SerializedPackage> CreateSerializedPackage(flatbuffers::FlatBufferBuilder &_fbb, const SerializedPackageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SerializedPackageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _serialized_package = _fbb.CreateVector(_o->serialized_package);
  return platforms::darwinn::CreateSerializedPackage(
      _fbb,
      _serialized_package);
}

inline PackageT *Package::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PackageT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Package::UnPackTo(PackageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = min_runtime_version(); _o->min_runtime_version = _e; }
  { auto _e = serialized_multi_executable(); if (_e) { _o->serialized_multi_executable.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->serialized_multi_executable.begin()); } }
  { auto _e = signature(); if (_e) { _o->signature.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->signature.begin()); } }
  { auto _e = keypair_version(); _o->keypair_version = _e; }
  { auto _e = compiler_version(); if (_e) _o->compiler_version = _e->str(); }
  { auto _e = virtual_chip_id(); _o->virtual_chip_id = _e; }
  { auto _e = multi_chip_package(); if (_e) { _o->multi_chip_package.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->multi_chip_package[_i] = std::unique_ptr<platforms::darwinn::SerializedPackageT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = model_identifier(); if (_e) _o->model_identifier = _e->str(); }
}

inline flatbuffers::Offset<Package> Package::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PackageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePackage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Package> CreatePackage(flatbuffers::FlatBufferBuilder &_fbb, const PackageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PackageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _min_runtime_version = _o->min_runtime_version;
  auto _serialized_multi_executable = _fbb.CreateVector(_o->serialized_multi_executable);
  auto _signature = _fbb.CreateVector(_o->signature);
  auto _keypair_version = _o->keypair_version;
  auto _compiler_version = _o->compiler_version.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->compiler_version);
  auto _virtual_chip_id = _o->virtual_chip_id;
  auto _multi_chip_package = _fbb.CreateVector<flatbuffers::Offset<platforms::darwinn::SerializedPackage>> (_o->multi_chip_package.size(), [](size_t i, _VectorArgs *__va) { return CreateSerializedPackage(*__va->__fbb, __va->__o->multi_chip_package[i].get(), __va->__rehasher); }, &_va );
  auto _model_identifier = _o->model_identifier.empty() ? _fbb.CreateSharedString("") : _fbb.CreateString(_o->model_identifier);
  return platforms::darwinn::CreatePackage(
      _fbb,
      _min_runtime_version,
      _serialized_multi_executable,
      _signature,
      _keypair_version,
      _compiler_version,
      _virtual_chip_id,
      _multi_chip_package,
      _model_identifier);
}

inline bool VerifyAnyHint(flatbuffers::Verifier &verifier, const void *obj, AnyHint type) {
  switch (type) {
    case AnyHint_NONE: {
      return true;
    }
    case AnyHint_DmaDescriptorHint: {
      auto ptr = reinterpret_cast<const platforms::darwinn::DmaDescriptorHint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyHint_InstructionHint: {
      auto ptr = reinterpret_cast<const platforms::darwinn::InstructionHint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyHint_InterruptHint: {
      auto ptr = reinterpret_cast<const platforms::darwinn::InterruptHint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyHint_FenceHint: {
      auto ptr = reinterpret_cast<const platforms::darwinn::FenceHint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAnyHintVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyHint(
        verifier,  values->Get(i), types->GetEnum<AnyHint>(i))) {
      return false;
    }
  }
  return true;
}

inline void *AnyHintUnion::UnPack(const void *obj, AnyHint type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case AnyHint_DmaDescriptorHint: {
      auto ptr = reinterpret_cast<const platforms::darwinn::DmaDescriptorHint *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyHint_InstructionHint: {
      auto ptr = reinterpret_cast<const platforms::darwinn::InstructionHint *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyHint_InterruptHint: {
      auto ptr = reinterpret_cast<const platforms::darwinn::InterruptHint *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyHint_FenceHint: {
      auto ptr = reinterpret_cast<const platforms::darwinn::FenceHint *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> AnyHintUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case AnyHint_DmaDescriptorHint: {
      auto ptr = reinterpret_cast<const platforms::darwinn::DmaDescriptorHintT *>(value);
      return CreateDmaDescriptorHint(_fbb, ptr, _rehasher).Union();
    }
    case AnyHint_InstructionHint: {
      auto ptr = reinterpret_cast<const platforms::darwinn::InstructionHintT *>(value);
      return CreateInstructionHint(_fbb, ptr, _rehasher).Union();
    }
    case AnyHint_InterruptHint: {
      auto ptr = reinterpret_cast<const platforms::darwinn::InterruptHintT *>(value);
      return CreateInterruptHint(_fbb, ptr, _rehasher).Union();
    }
    case AnyHint_FenceHint: {
      auto ptr = reinterpret_cast<const platforms::darwinn::FenceHintT *>(value);
      return CreateFenceHint(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline AnyHintUnion::AnyHintUnion(const AnyHintUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case AnyHint_DmaDescriptorHint: {
      FLATBUFFERS_ASSERT(false);  // platforms::darwinn::DmaDescriptorHintT not copyable.
      break;
    }
    case AnyHint_InstructionHint: {
      value = new platforms::darwinn::InstructionHintT(*reinterpret_cast<platforms::darwinn::InstructionHintT *>(u.value));
      break;
    }
    case AnyHint_InterruptHint: {
      value = new platforms::darwinn::InterruptHintT(*reinterpret_cast<platforms::darwinn::InterruptHintT *>(u.value));
      break;
    }
    case AnyHint_FenceHint: {
      value = new platforms::darwinn::FenceHintT(*reinterpret_cast<platforms::darwinn::FenceHintT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void AnyHintUnion::Reset() {
  switch (type) {
    case AnyHint_DmaDescriptorHint: {
      auto ptr = reinterpret_cast<platforms::darwinn::DmaDescriptorHintT *>(value);
      delete ptr;
      break;
    }
    case AnyHint_InstructionHint: {
      auto ptr = reinterpret_cast<platforms::darwinn::InstructionHintT *>(value);
      delete ptr;
      break;
    }
    case AnyHint_InterruptHint: {
      auto ptr = reinterpret_cast<platforms::darwinn::InterruptHintT *>(value);
      delete ptr;
      break;
    }
    case AnyHint_FenceHint: {
      auto ptr = reinterpret_cast<platforms::darwinn::FenceHintT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = AnyHint_NONE;
}

inline bool VerifyAnyLayer(flatbuffers::Verifier &verifier, const void *obj, AnyLayer type) {
  switch (type) {
    case AnyLayer_NONE: {
      return true;
    }
    case AnyLayer_OutputLayer: {
      auto ptr = reinterpret_cast<const platforms::darwinn::OutputLayer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyLayer_InputLayer: {
      auto ptr = reinterpret_cast<const platforms::darwinn::InputLayer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAnyLayerVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyLayer(
        verifier,  values->Get(i), types->GetEnum<AnyLayer>(i))) {
      return false;
    }
  }
  return true;
}

inline void *AnyLayerUnion::UnPack(const void *obj, AnyLayer type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case AnyLayer_OutputLayer: {
      auto ptr = reinterpret_cast<const platforms::darwinn::OutputLayer *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyLayer_InputLayer: {
      auto ptr = reinterpret_cast<const platforms::darwinn::InputLayer *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> AnyLayerUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case AnyLayer_OutputLayer: {
      auto ptr = reinterpret_cast<const platforms::darwinn::OutputLayerT *>(value);
      return CreateOutputLayer(_fbb, ptr, _rehasher).Union();
    }
    case AnyLayer_InputLayer: {
      auto ptr = reinterpret_cast<const platforms::darwinn::InputLayerT *>(value);
      return CreateInputLayer(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline AnyLayerUnion::AnyLayerUnion(const AnyLayerUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case AnyLayer_OutputLayer: {
      FLATBUFFERS_ASSERT(false);  // platforms::darwinn::OutputLayerT not copyable.
      break;
    }
    case AnyLayer_InputLayer: {
      value = new platforms::darwinn::InputLayerT(*reinterpret_cast<platforms::darwinn::InputLayerT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void AnyLayerUnion::Reset() {
  switch (type) {
    case AnyLayer_OutputLayer: {
      auto ptr = reinterpret_cast<platforms::darwinn::OutputLayerT *>(value);
      delete ptr;
      break;
    }
    case AnyLayer_InputLayer: {
      auto ptr = reinterpret_cast<platforms::darwinn::InputLayerT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = AnyLayer_NONE;
}

inline const platforms::darwinn::Package *GetPackage(const void *buf) {
  return flatbuffers::GetRoot<platforms::darwinn::Package>(buf);
}

inline const platforms::darwinn::Package *GetSizePrefixedPackage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<platforms::darwinn::Package>(buf);
}

inline Package *GetMutablePackage(void *buf) {
  return flatbuffers::GetMutableRoot<Package>(buf);
}

inline const char *PackageIdentifier() {
  return "DWN1";
}

inline bool PackageBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, PackageIdentifier());
}

inline bool VerifyPackageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<platforms::darwinn::Package>(PackageIdentifier());
}

inline bool VerifySizePrefixedPackageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<platforms::darwinn::Package>(PackageIdentifier());
}

inline void FinishPackageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<platforms::darwinn::Package> root) {
  fbb.Finish(root, PackageIdentifier());
}

inline void FinishSizePrefixedPackageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<platforms::darwinn::Package> root) {
  fbb.FinishSizePrefixed(root, PackageIdentifier());
}

inline std::unique_ptr<platforms::darwinn::PackageT> UnPackPackage(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<platforms::darwinn::PackageT>(GetPackage(buf)->UnPack(res));
}

inline std::unique_ptr<platforms::darwinn::PackageT> UnPackSizePrefixedPackage(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<platforms::darwinn::PackageT>(GetSizePrefixedPackage(buf)->UnPack(res));
}

}  // namespace darwinn
}  // namespace platforms

#endif  // FLATBUFFERS_GENERATED_EXECUTABLE_PLATFORMS_DARWINN_H_
